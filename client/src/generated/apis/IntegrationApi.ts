/* tslint:disable */
/* eslint-disable */
/**
 * Платформа Духовных Практик Gateway API
 *          ## Публичный REST API шлюз для платформы духовных практик                  ### Аутентификация         Все эндпоинты (кроме `/api/v1/auth/_*`) требуют JWT Bearer токен в заголовке Authorization.                  ### Основные возможности:         - **Цели (Goals)**: Управление духовными целями пользователей         - **Тасбих (Tasbih)**: Счетчик для духовных практик         - **Азкары (Azkar)**: Ежедневные поминания         - **Quran API**: Работа с Кораном, переводами и аудио         - **Библиотека**: Управление пользовательским контентом         - **Отчеты**: Генерация отчетов о духовной активности                  ### Статус коды:         - `200` - Успешный запрос         - `201` - Ресурс создан         - `400` - Неверный формат запроса         - `401` - Требуется авторизация         - `403` - Доступ запрещен         - `404` - Ресурс не найден         - `422` - Ошибка валидации данных         - `500` - Внутренняя ошибка сервера         - `503` - Сервис недоступен                  ### Health Checks:         - `GET /health` - Базовый health check         - `GET /health/ready` - Readiness probe (Kubernetes)         - `GET /health/live` - Liveness probe (Kubernetes)         - `GET /metrics` - Prometheus метрики         
 *
 * The version of the OpenAPI document: 1.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BodySemanticMatchApiV1BridgeSemanticMatchPost,
  HTTPValidationError,
} from '../models/index';
import {
    BodySemanticMatchApiV1BridgeSemanticMatchPostFromJSON,
    BodySemanticMatchApiV1BridgeSemanticMatchPostToJSON,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
} from '../models/index';

export interface AnalyzeTextApiV1BridgeContextAnalyzePostRequest {
    text: string;
    contextType: string;
}

export interface AutoCreateLinksApiV1BridgeAutoLinkPostRequest {
    sourceType: string;
    sourceId: string;
    targetType: string;
    linkType: string;
    requestBody: Array<string>;
    strength?: number;
    createdBy?: string;
}

export interface BulkCreateLinksApiV1BridgeBulkLinksPostRequest {
    requestBody: Array<{ [key: string]: any; }>;
}

export interface CreateAnnotationApiV1BridgeAnnotationsPostRequest {
    requestBody: { [key: string]: any; };
}

export interface CreateEmbeddingApiV1BridgeEmbeddingsPostRequest {
    requestBody: { [key: string]: any; };
}

export interface CreateLinkApiV1BridgeLinksPostRequest {
    requestBody: { [key: string]: any; };
}

export interface CreateRuleApiV1BridgeRulesPostRequest {
    requestBody: { [key: string]: any; };
}

export interface DeleteAnnotationApiV1BridgeAnnotationsAnnotationIdDeleteRequest {
    annotationId: string;
}

export interface DeleteEmbeddingApiV1BridgeEmbeddingsEmbeddingIdDeleteRequest {
    embeddingId: string;
}

export interface DeleteLinkApiV1BridgeLinksLinkIdDeleteRequest {
    linkId: string;
}

export interface DeleteRuleApiV1BridgeRulesRuleIdDeleteRequest {
    ruleId: string;
}

export interface EnrichContextApiV1BridgeContextEnrichGetRequest {
    entityType: string;
    entityId: string;
}

export interface GetAllRulesApiV1BridgeRulesGetRequest {
    isActive?: boolean;
}

export interface GetAnnotationApiV1BridgeAnnotationsAnnotationIdGetRequest {
    annotationId: string;
}

export interface GetAnnotationsByKnowledgeEntryApiV1BridgeAnnotationsKnowledgeKnowledgeEntryIdGetRequest {
    knowledgeEntryId: string;
}

export interface GetAnnotationsByTargetApiV1BridgeAnnotationsTargetTypeTargetIdGetRequest {
    targetType: string;
    targetId: string;
}

export interface GetAnnotationsInRangeApiV1BridgeAnnotationsRangeTargetTypeTargetIdGetRequest {
    targetType: string;
    targetId: string;
    startPos: number;
    endPos: number;
}

export interface GetBidirectionalLinksApiV1BridgeLinksBidirectionalEntity1TypeEntity1IdEntity2TypeEntity2IdGetRequest {
    entity1Type: string;
    entity1Id: string;
    entity2Type: string;
    entity2Id: string;
}

export interface GetEmbeddingByEntityApiV1BridgeEmbeddingsEntityTypeEntityIdGetRequest {
    entityType: string;
    entityId: string;
}

export interface GetEmbeddingsByModelApiV1BridgeEmbeddingsModelEmbeddingModelGetRequest {
    embeddingModel: string;
    limit?: number;
}

export interface GetEntityGraphApiV1BridgeGraphEntityTypeEntityIdGetRequest {
    entityType: string;
    entityId: string;
    depth?: number;
    maxLinks?: number;
}

export interface GetLinkApiV1BridgeLinksLinkIdGetRequest {
    linkId: string;
}

export interface GetLinksBySourceApiV1BridgeLinksSourceSourceTypeSourceIdGetRequest {
    sourceType: string;
    sourceId: string;
}

export interface GetLinksByTargetApiV1BridgeLinksTargetTargetTypeTargetIdGetRequest {
    targetType: string;
    targetId: string;
}

export interface GetLinksByTypeApiV1BridgeLinksTypeLinkTypeGetRequest {
    linkType: string;
    limit?: number;
}

export interface GetRelatedContentApiV1BridgeContextRelatedGetRequest {
    fromEntity: string;
    toType: string;
    limit?: number;
}

export interface GetRelatedEntitiesApiV1BridgeLinksRelatedSourceTypeSourceIdGetRequest {
    sourceType: string;
    sourceId: string;
    targetType?: string | null;
    linkType?: string | null;
    minStrength?: number;
    limit?: number;
}

export interface GetRuleApiV1BridgeRulesRuleIdGetRequest {
    ruleId: string;
}

export interface GetRulesByTypeApiV1BridgeRulesTypeRuleTypeGetRequest {
    ruleType: string;
}

export interface RecommendLinksApiV1BridgeRecommendLinksGetRequest {
    entityType: string;
    entityId: string;
}

export interface SemanticMatchApiV1BridgeSemanticMatchPostRequest {
    bodySemanticMatchApiV1BridgeSemanticMatchPost: BodySemanticMatchApiV1BridgeSemanticMatchPost;
}

export interface SuggestLinksApiV1BridgeSuggestLinksSourceTypeSourceIdGetRequest {
    sourceType: string;
    sourceId: string;
    targetType: string;
    limit?: number;
}

export interface UpdateAnnotationApiV1BridgeAnnotationsAnnotationIdPutRequest {
    annotationId: string;
    requestBody: { [key: string]: any; };
}

export interface UpdateEmbeddingApiV1BridgeEmbeddingsEmbeddingIdPutRequest {
    embeddingId: string;
    requestBody: { [key: string]: any; };
}

export interface UpdateLinkApiV1BridgeLinksLinkIdPutRequest {
    linkId: string;
    requestBody: { [key: string]: any; };
}

export interface UpdateRuleApiV1BridgeRulesRuleIdPutRequest {
    ruleId: string;
    requestBody: { [key: string]: any; };
}

/**
 * IntegrationApi - interface
 * 
 * @export
 * @interface IntegrationApiInterface
 */
export interface IntegrationApiInterface {
    /**
     * Проанализировать текст на термины
     * @summary Analyze Text
     * @param {string} text 
     * @param {string} contextType Тип контекста
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    analyzeTextApiV1BridgeContextAnalyzePostRaw(requestParameters: AnalyzeTextApiV1BridgeContextAnalyzePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Проанализировать текст на термины
     * Analyze Text
     */
    analyzeTextApiV1BridgeContextAnalyzePost(requestParameters: AnalyzeTextApiV1BridgeContextAnalyzePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Автоматически создать связи между сущностями (только для админов)
     * @summary Auto Create Links
     * @param {string} sourceType 
     * @param {string} sourceId 
     * @param {string} targetType 
     * @param {string} linkType 
     * @param {Array<string>} requestBody 
     * @param {number} [strength] 
     * @param {string} [createdBy] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    autoCreateLinksApiV1BridgeAutoLinkPostRaw(requestParameters: AutoCreateLinksApiV1BridgeAutoLinkPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Автоматически создать связи между сущностями (только для админов)
     * Auto Create Links
     */
    autoCreateLinksApiV1BridgeAutoLinkPost(requestParameters: AutoCreateLinksApiV1BridgeAutoLinkPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Массовое создание связей (только для админов)
     * @summary Bulk Create Links
     * @param {Array<{ [key: string]: any; }>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    bulkCreateLinksApiV1BridgeBulkLinksPostRaw(requestParameters: BulkCreateLinksApiV1BridgeBulkLinksPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Массовое создание связей (только для админов)
     * Bulk Create Links
     */
    bulkCreateLinksApiV1BridgeBulkLinksPost(requestParameters: BulkCreateLinksApiV1BridgeBulkLinksPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Создать новую аннотацию (только для админов)
     * @summary Create Annotation
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    createAnnotationApiV1BridgeAnnotationsPostRaw(requestParameters: CreateAnnotationApiV1BridgeAnnotationsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Создать новую аннотацию (только для админов)
     * Create Annotation
     */
    createAnnotationApiV1BridgeAnnotationsPost(requestParameters: CreateAnnotationApiV1BridgeAnnotationsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Создать новый вектор (только для админов)
     * @summary Create Embedding
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    createEmbeddingApiV1BridgeEmbeddingsPostRaw(requestParameters: CreateEmbeddingApiV1BridgeEmbeddingsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Создать новый вектор (только для админов)
     * Create Embedding
     */
    createEmbeddingApiV1BridgeEmbeddingsPost(requestParameters: CreateEmbeddingApiV1BridgeEmbeddingsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Создать новую связь (только для админов)
     * @summary Create Link
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    createLinkApiV1BridgeLinksPostRaw(requestParameters: CreateLinkApiV1BridgeLinksPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Создать новую связь (только для админов)
     * Create Link
     */
    createLinkApiV1BridgeLinksPost(requestParameters: CreateLinkApiV1BridgeLinksPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Создать новое правило (только для админов)
     * @summary Create Rule
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    createRuleApiV1BridgeRulesPostRaw(requestParameters: CreateRuleApiV1BridgeRulesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Создать новое правило (только для админов)
     * Create Rule
     */
    createRuleApiV1BridgeRulesPost(requestParameters: CreateRuleApiV1BridgeRulesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Удалить аннотацию (только для админов)
     * @summary Delete Annotation
     * @param {string} annotationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    deleteAnnotationApiV1BridgeAnnotationsAnnotationIdDeleteRaw(requestParameters: DeleteAnnotationApiV1BridgeAnnotationsAnnotationIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Удалить аннотацию (только для админов)
     * Delete Annotation
     */
    deleteAnnotationApiV1BridgeAnnotationsAnnotationIdDelete(requestParameters: DeleteAnnotationApiV1BridgeAnnotationsAnnotationIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Удалить вектор (только для админов)
     * @summary Delete Embedding
     * @param {string} embeddingId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    deleteEmbeddingApiV1BridgeEmbeddingsEmbeddingIdDeleteRaw(requestParameters: DeleteEmbeddingApiV1BridgeEmbeddingsEmbeddingIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Удалить вектор (только для админов)
     * Delete Embedding
     */
    deleteEmbeddingApiV1BridgeEmbeddingsEmbeddingIdDelete(requestParameters: DeleteEmbeddingApiV1BridgeEmbeddingsEmbeddingIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Удалить связь (только для админов)
     * @summary Delete Link
     * @param {string} linkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    deleteLinkApiV1BridgeLinksLinkIdDeleteRaw(requestParameters: DeleteLinkApiV1BridgeLinksLinkIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Удалить связь (только для админов)
     * Delete Link
     */
    deleteLinkApiV1BridgeLinksLinkIdDelete(requestParameters: DeleteLinkApiV1BridgeLinksLinkIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Удалить правило (только для админов)
     * @summary Delete Rule
     * @param {string} ruleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    deleteRuleApiV1BridgeRulesRuleIdDeleteRaw(requestParameters: DeleteRuleApiV1BridgeRulesRuleIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Удалить правило (только для админов)
     * Delete Rule
     */
    deleteRuleApiV1BridgeRulesRuleIdDelete(requestParameters: DeleteRuleApiV1BridgeRulesRuleIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Обогатить контекст сущности
     * @summary Enrich Context
     * @param {string} entityType 
     * @param {string} entityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    enrichContextApiV1BridgeContextEnrichGetRaw(requestParameters: EnrichContextApiV1BridgeContextEnrichGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Обогатить контекст сущности
     * Enrich Context
     */
    enrichContextApiV1BridgeContextEnrichGet(requestParameters: EnrichContextApiV1BridgeContextEnrichGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить все правила
     * @summary Get All Rules
     * @param {boolean} [isActive] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    getAllRulesApiV1BridgeRulesGetRaw(requestParameters: GetAllRulesApiV1BridgeRulesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить все правила
     * Get All Rules
     */
    getAllRulesApiV1BridgeRulesGet(requestParameters: GetAllRulesApiV1BridgeRulesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить аннотацию по ID
     * @summary Get Annotation
     * @param {string} annotationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    getAnnotationApiV1BridgeAnnotationsAnnotationIdGetRaw(requestParameters: GetAnnotationApiV1BridgeAnnotationsAnnotationIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить аннотацию по ID
     * Get Annotation
     */
    getAnnotationApiV1BridgeAnnotationsAnnotationIdGet(requestParameters: GetAnnotationApiV1BridgeAnnotationsAnnotationIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить статистику по аннотациям
     * @summary Get Annotation Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    getAnnotationStatsApiV1BridgeStatsAnnotationsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить статистику по аннотациям
     * Get Annotation Stats
     */
    getAnnotationStatsApiV1BridgeStatsAnnotationsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить аннотации для записи знаний
     * @summary Get Annotations By Knowledge Entry
     * @param {string} knowledgeEntryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    getAnnotationsByKnowledgeEntryApiV1BridgeAnnotationsKnowledgeKnowledgeEntryIdGetRaw(requestParameters: GetAnnotationsByKnowledgeEntryApiV1BridgeAnnotationsKnowledgeKnowledgeEntryIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить аннотации для записи знаний
     * Get Annotations By Knowledge Entry
     */
    getAnnotationsByKnowledgeEntryApiV1BridgeAnnotationsKnowledgeKnowledgeEntryIdGet(requestParameters: GetAnnotationsByKnowledgeEntryApiV1BridgeAnnotationsKnowledgeKnowledgeEntryIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить аннотации для цели
     * @summary Get Annotations By Target
     * @param {string} targetType 
     * @param {string} targetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    getAnnotationsByTargetApiV1BridgeAnnotationsTargetTypeTargetIdGetRaw(requestParameters: GetAnnotationsByTargetApiV1BridgeAnnotationsTargetTypeTargetIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить аннотации для цели
     * Get Annotations By Target
     */
    getAnnotationsByTargetApiV1BridgeAnnotationsTargetTypeTargetIdGet(requestParameters: GetAnnotationsByTargetApiV1BridgeAnnotationsTargetTypeTargetIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить аннотации в определенном диапазоне позиций
     * @summary Get Annotations In Range
     * @param {string} targetType 
     * @param {string} targetId 
     * @param {number} startPos Начальная позиция
     * @param {number} endPos Конечная позиция
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    getAnnotationsInRangeApiV1BridgeAnnotationsRangeTargetTypeTargetIdGetRaw(requestParameters: GetAnnotationsInRangeApiV1BridgeAnnotationsRangeTargetTypeTargetIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить аннотации в определенном диапазоне позиций
     * Get Annotations In Range
     */
    getAnnotationsInRangeApiV1BridgeAnnotationsRangeTargetTypeTargetIdGet(requestParameters: GetAnnotationsInRangeApiV1BridgeAnnotationsRangeTargetTypeTargetIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить двунаправленные связи между двумя сущностями
     * @summary Get Bidirectional Links
     * @param {string} entity1Type 
     * @param {string} entity1Id 
     * @param {string} entity2Type 
     * @param {string} entity2Id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    getBidirectionalLinksApiV1BridgeLinksBidirectionalEntity1TypeEntity1IdEntity2TypeEntity2IdGetRaw(requestParameters: GetBidirectionalLinksApiV1BridgeLinksBidirectionalEntity1TypeEntity1IdEntity2TypeEntity2IdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить двунаправленные связи между двумя сущностями
     * Get Bidirectional Links
     */
    getBidirectionalLinksApiV1BridgeLinksBidirectionalEntity1TypeEntity1IdEntity2TypeEntity2IdGet(requestParameters: GetBidirectionalLinksApiV1BridgeLinksBidirectionalEntity1TypeEntity1IdEntity2TypeEntity2IdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить вектор для сущности
     * @summary Get Embedding By Entity
     * @param {string} entityType 
     * @param {string} entityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    getEmbeddingByEntityApiV1BridgeEmbeddingsEntityTypeEntityIdGetRaw(requestParameters: GetEmbeddingByEntityApiV1BridgeEmbeddingsEntityTypeEntityIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить вектор для сущности
     * Get Embedding By Entity
     */
    getEmbeddingByEntityApiV1BridgeEmbeddingsEntityTypeEntityIdGet(requestParameters: GetEmbeddingByEntityApiV1BridgeEmbeddingsEntityTypeEntityIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить векторы по модели
     * @summary Get Embeddings By Model
     * @param {string} embeddingModel 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    getEmbeddingsByModelApiV1BridgeEmbeddingsModelEmbeddingModelGetRaw(requestParameters: GetEmbeddingsByModelApiV1BridgeEmbeddingsModelEmbeddingModelGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить векторы по модели
     * Get Embeddings By Model
     */
    getEmbeddingsByModelApiV1BridgeEmbeddingsModelEmbeddingModelGet(requestParameters: GetEmbeddingsByModelApiV1BridgeEmbeddingsModelEmbeddingModelGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить граф связей для сущности
     * @summary Get Entity Graph
     * @param {string} entityType 
     * @param {string} entityId 
     * @param {number} [depth] 
     * @param {number} [maxLinks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    getEntityGraphApiV1BridgeGraphEntityTypeEntityIdGetRaw(requestParameters: GetEntityGraphApiV1BridgeGraphEntityTypeEntityIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить граф связей для сущности
     * Get Entity Graph
     */
    getEntityGraphApiV1BridgeGraphEntityTypeEntityIdGet(requestParameters: GetEntityGraphApiV1BridgeGraphEntityTypeEntityIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить связь по ID
     * @summary Get Link
     * @param {string} linkId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    getLinkApiV1BridgeLinksLinkIdGetRaw(requestParameters: GetLinkApiV1BridgeLinksLinkIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить связь по ID
     * Get Link
     */
    getLinkApiV1BridgeLinksLinkIdGet(requestParameters: GetLinkApiV1BridgeLinksLinkIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить статистику по связям
     * @summary Get Link Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    getLinkStatsApiV1BridgeStatsLinksGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить статистику по связям
     * Get Link Stats
     */
    getLinkStatsApiV1BridgeStatsLinksGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить все связи от источника
     * @summary Get Links By Source
     * @param {string} sourceType 
     * @param {string} sourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    getLinksBySourceApiV1BridgeLinksSourceSourceTypeSourceIdGetRaw(requestParameters: GetLinksBySourceApiV1BridgeLinksSourceSourceTypeSourceIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить все связи от источника
     * Get Links By Source
     */
    getLinksBySourceApiV1BridgeLinksSourceSourceTypeSourceIdGet(requestParameters: GetLinksBySourceApiV1BridgeLinksSourceSourceTypeSourceIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить все связи к цели
     * @summary Get Links By Target
     * @param {string} targetType 
     * @param {string} targetId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    getLinksByTargetApiV1BridgeLinksTargetTargetTypeTargetIdGetRaw(requestParameters: GetLinksByTargetApiV1BridgeLinksTargetTargetTypeTargetIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить все связи к цели
     * Get Links By Target
     */
    getLinksByTargetApiV1BridgeLinksTargetTargetTypeTargetIdGet(requestParameters: GetLinksByTargetApiV1BridgeLinksTargetTargetTypeTargetIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить связи определенного типа
     * @summary Get Links By Type
     * @param {string} linkType 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    getLinksByTypeApiV1BridgeLinksTypeLinkTypeGetRaw(requestParameters: GetLinksByTypeApiV1BridgeLinksTypeLinkTypeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить связи определенного типа
     * Get Links By Type
     */
    getLinksByTypeApiV1BridgeLinksTypeLinkTypeGet(requestParameters: GetLinksByTypeApiV1BridgeLinksTypeLinkTypeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Найти связанное содержимое
     * @summary Get Related Content
     * @param {string} fromEntity От сущности (type:id)
     * @param {string} toType К типу
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    getRelatedContentApiV1BridgeContextRelatedGetRaw(requestParameters: GetRelatedContentApiV1BridgeContextRelatedGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Найти связанное содержимое
     * Get Related Content
     */
    getRelatedContentApiV1BridgeContextRelatedGet(requestParameters: GetRelatedContentApiV1BridgeContextRelatedGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Найти связанные сущности
     * @summary Get Related Entities
     * @param {string} sourceType 
     * @param {string} sourceId 
     * @param {string} [targetType] 
     * @param {string} [linkType] 
     * @param {number} [minStrength] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    getRelatedEntitiesApiV1BridgeLinksRelatedSourceTypeSourceIdGetRaw(requestParameters: GetRelatedEntitiesApiV1BridgeLinksRelatedSourceTypeSourceIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Найти связанные сущности
     * Get Related Entities
     */
    getRelatedEntitiesApiV1BridgeLinksRelatedSourceTypeSourceIdGet(requestParameters: GetRelatedEntitiesApiV1BridgeLinksRelatedSourceTypeSourceIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить правило по ID
     * @summary Get Rule
     * @param {string} ruleId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    getRuleApiV1BridgeRulesRuleIdGetRaw(requestParameters: GetRuleApiV1BridgeRulesRuleIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить правило по ID
     * Get Rule
     */
    getRuleApiV1BridgeRulesRuleIdGet(requestParameters: GetRuleApiV1BridgeRulesRuleIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить правила определенного типа
     * @summary Get Rules By Type
     * @param {string} ruleType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    getRulesByTypeApiV1BridgeRulesTypeRuleTypeGetRaw(requestParameters: GetRulesByTypeApiV1BridgeRulesTypeRuleTypeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить правила определенного типа
     * Get Rules By Type
     */
    getRulesByTypeApiV1BridgeRulesTypeRuleTypeGet(requestParameters: GetRulesByTypeApiV1BridgeRulesTypeRuleTypeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Проверка здоровья API
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    healthCheckApiV1BridgeHealthGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Проверка здоровья API
     * Health Check
     */
    healthCheckApiV1BridgeHealthGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Предложить связи для сущности (заглушка для будущей реализации)
     * @summary Recommend Links
     * @param {string} entityType 
     * @param {string} entityId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    recommendLinksApiV1BridgeRecommendLinksGetRaw(requestParameters: RecommendLinksApiV1BridgeRecommendLinksGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Предложить связи для сущности (заглушка для будущей реализации)
     * Recommend Links
     */
    recommendLinksApiV1BridgeRecommendLinksGet(requestParameters: RecommendLinksApiV1BridgeRecommendLinksGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Семантическое сопоставление (заглушка для будущей реализации)
     * @summary Semantic Match
     * @param {BodySemanticMatchApiV1BridgeSemanticMatchPost} bodySemanticMatchApiV1BridgeSemanticMatchPost 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    semanticMatchApiV1BridgeSemanticMatchPostRaw(requestParameters: SemanticMatchApiV1BridgeSemanticMatchPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Семантическое сопоставление (заглушка для будущей реализации)
     * Semantic Match
     */
    semanticMatchApiV1BridgeSemanticMatchPost(requestParameters: SemanticMatchApiV1BridgeSemanticMatchPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Предложить возможные связи на основе существующих паттернов
     * @summary Suggest Links
     * @param {string} sourceType 
     * @param {string} sourceId 
     * @param {string} targetType 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    suggestLinksApiV1BridgeSuggestLinksSourceTypeSourceIdGetRaw(requestParameters: SuggestLinksApiV1BridgeSuggestLinksSourceTypeSourceIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Предложить возможные связи на основе существующих паттернов
     * Suggest Links
     */
    suggestLinksApiV1BridgeSuggestLinksSourceTypeSourceIdGet(requestParameters: SuggestLinksApiV1BridgeSuggestLinksSourceTypeSourceIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Обновить аннотацию (только для админов)
     * @summary Update Annotation
     * @param {string} annotationId 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    updateAnnotationApiV1BridgeAnnotationsAnnotationIdPutRaw(requestParameters: UpdateAnnotationApiV1BridgeAnnotationsAnnotationIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Обновить аннотацию (только для админов)
     * Update Annotation
     */
    updateAnnotationApiV1BridgeAnnotationsAnnotationIdPut(requestParameters: UpdateAnnotationApiV1BridgeAnnotationsAnnotationIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Обновить вектор (только для админов)
     * @summary Update Embedding
     * @param {string} embeddingId 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    updateEmbeddingApiV1BridgeEmbeddingsEmbeddingIdPutRaw(requestParameters: UpdateEmbeddingApiV1BridgeEmbeddingsEmbeddingIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Обновить вектор (только для админов)
     * Update Embedding
     */
    updateEmbeddingApiV1BridgeEmbeddingsEmbeddingIdPut(requestParameters: UpdateEmbeddingApiV1BridgeEmbeddingsEmbeddingIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Обновить связь (только для админов)
     * @summary Update Link
     * @param {string} linkId 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    updateLinkApiV1BridgeLinksLinkIdPutRaw(requestParameters: UpdateLinkApiV1BridgeLinksLinkIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Обновить связь (только для админов)
     * Update Link
     */
    updateLinkApiV1BridgeLinksLinkIdPut(requestParameters: UpdateLinkApiV1BridgeLinksLinkIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Обновить правило (только для админов)
     * @summary Update Rule
     * @param {string} ruleId 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IntegrationApiInterface
     */
    updateRuleApiV1BridgeRulesRuleIdPutRaw(requestParameters: UpdateRuleApiV1BridgeRulesRuleIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Обновить правило (только для админов)
     * Update Rule
     */
    updateRuleApiV1BridgeRulesRuleIdPut(requestParameters: UpdateRuleApiV1BridgeRulesRuleIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

}

/**
 * 
 */
export class IntegrationApi extends runtime.BaseAPI implements IntegrationApiInterface {

    /**
     * Проанализировать текст на термины
     * Analyze Text
     */
    async analyzeTextApiV1BridgeContextAnalyzePostRaw(requestParameters: AnalyzeTextApiV1BridgeContextAnalyzePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['text'] == null) {
            throw new runtime.RequiredError(
                'text',
                'Required parameter "text" was null or undefined when calling analyzeTextApiV1BridgeContextAnalyzePost().'
            );
        }

        if (requestParameters['contextType'] == null) {
            throw new runtime.RequiredError(
                'contextType',
                'Required parameter "contextType" was null or undefined when calling analyzeTextApiV1BridgeContextAnalyzePost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['text'] != null) {
            queryParameters['text'] = requestParameters['text'];
        }

        if (requestParameters['contextType'] != null) {
            queryParameters['context_type'] = requestParameters['contextType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/context/analyze`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Проанализировать текст на термины
     * Analyze Text
     */
    async analyzeTextApiV1BridgeContextAnalyzePost(requestParameters: AnalyzeTextApiV1BridgeContextAnalyzePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.analyzeTextApiV1BridgeContextAnalyzePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Автоматически создать связи между сущностями (только для админов)
     * Auto Create Links
     */
    async autoCreateLinksApiV1BridgeAutoLinkPostRaw(requestParameters: AutoCreateLinksApiV1BridgeAutoLinkPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['sourceType'] == null) {
            throw new runtime.RequiredError(
                'sourceType',
                'Required parameter "sourceType" was null or undefined when calling autoCreateLinksApiV1BridgeAutoLinkPost().'
            );
        }

        if (requestParameters['sourceId'] == null) {
            throw new runtime.RequiredError(
                'sourceId',
                'Required parameter "sourceId" was null or undefined when calling autoCreateLinksApiV1BridgeAutoLinkPost().'
            );
        }

        if (requestParameters['targetType'] == null) {
            throw new runtime.RequiredError(
                'targetType',
                'Required parameter "targetType" was null or undefined when calling autoCreateLinksApiV1BridgeAutoLinkPost().'
            );
        }

        if (requestParameters['linkType'] == null) {
            throw new runtime.RequiredError(
                'linkType',
                'Required parameter "linkType" was null or undefined when calling autoCreateLinksApiV1BridgeAutoLinkPost().'
            );
        }

        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling autoCreateLinksApiV1BridgeAutoLinkPost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['sourceType'] != null) {
            queryParameters['source_type'] = requestParameters['sourceType'];
        }

        if (requestParameters['sourceId'] != null) {
            queryParameters['source_id'] = requestParameters['sourceId'];
        }

        if (requestParameters['targetType'] != null) {
            queryParameters['target_type'] = requestParameters['targetType'];
        }

        if (requestParameters['linkType'] != null) {
            queryParameters['link_type'] = requestParameters['linkType'];
        }

        if (requestParameters['strength'] != null) {
            queryParameters['strength'] = requestParameters['strength'];
        }

        if (requestParameters['createdBy'] != null) {
            queryParameters['created_by'] = requestParameters['createdBy'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/auto-link`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Автоматически создать связи между сущностями (только для админов)
     * Auto Create Links
     */
    async autoCreateLinksApiV1BridgeAutoLinkPost(requestParameters: AutoCreateLinksApiV1BridgeAutoLinkPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.autoCreateLinksApiV1BridgeAutoLinkPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Массовое создание связей (только для админов)
     * Bulk Create Links
     */
    async bulkCreateLinksApiV1BridgeBulkLinksPostRaw(requestParameters: BulkCreateLinksApiV1BridgeBulkLinksPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling bulkCreateLinksApiV1BridgeBulkLinksPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/bulk-links`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Массовое создание связей (только для админов)
     * Bulk Create Links
     */
    async bulkCreateLinksApiV1BridgeBulkLinksPost(requestParameters: BulkCreateLinksApiV1BridgeBulkLinksPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.bulkCreateLinksApiV1BridgeBulkLinksPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Создать новую аннотацию (только для админов)
     * Create Annotation
     */
    async createAnnotationApiV1BridgeAnnotationsPostRaw(requestParameters: CreateAnnotationApiV1BridgeAnnotationsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling createAnnotationApiV1BridgeAnnotationsPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/annotations`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Создать новую аннотацию (только для админов)
     * Create Annotation
     */
    async createAnnotationApiV1BridgeAnnotationsPost(requestParameters: CreateAnnotationApiV1BridgeAnnotationsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.createAnnotationApiV1BridgeAnnotationsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Создать новый вектор (только для админов)
     * Create Embedding
     */
    async createEmbeddingApiV1BridgeEmbeddingsPostRaw(requestParameters: CreateEmbeddingApiV1BridgeEmbeddingsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling createEmbeddingApiV1BridgeEmbeddingsPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/embeddings`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Создать новый вектор (только для админов)
     * Create Embedding
     */
    async createEmbeddingApiV1BridgeEmbeddingsPost(requestParameters: CreateEmbeddingApiV1BridgeEmbeddingsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.createEmbeddingApiV1BridgeEmbeddingsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Создать новую связь (только для админов)
     * Create Link
     */
    async createLinkApiV1BridgeLinksPostRaw(requestParameters: CreateLinkApiV1BridgeLinksPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling createLinkApiV1BridgeLinksPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/links`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Создать новую связь (только для админов)
     * Create Link
     */
    async createLinkApiV1BridgeLinksPost(requestParameters: CreateLinkApiV1BridgeLinksPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.createLinkApiV1BridgeLinksPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Создать новое правило (только для админов)
     * Create Rule
     */
    async createRuleApiV1BridgeRulesPostRaw(requestParameters: CreateRuleApiV1BridgeRulesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling createRuleApiV1BridgeRulesPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/rules`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Создать новое правило (только для админов)
     * Create Rule
     */
    async createRuleApiV1BridgeRulesPost(requestParameters: CreateRuleApiV1BridgeRulesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.createRuleApiV1BridgeRulesPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Удалить аннотацию (только для админов)
     * Delete Annotation
     */
    async deleteAnnotationApiV1BridgeAnnotationsAnnotationIdDeleteRaw(requestParameters: DeleteAnnotationApiV1BridgeAnnotationsAnnotationIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['annotationId'] == null) {
            throw new runtime.RequiredError(
                'annotationId',
                'Required parameter "annotationId" was null or undefined when calling deleteAnnotationApiV1BridgeAnnotationsAnnotationIdDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/annotations/{annotation_id}`;
        urlPath = urlPath.replace(`{${"annotation_id"}}`, encodeURIComponent(String(requestParameters['annotationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Удалить аннотацию (только для админов)
     * Delete Annotation
     */
    async deleteAnnotationApiV1BridgeAnnotationsAnnotationIdDelete(requestParameters: DeleteAnnotationApiV1BridgeAnnotationsAnnotationIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deleteAnnotationApiV1BridgeAnnotationsAnnotationIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Удалить вектор (только для админов)
     * Delete Embedding
     */
    async deleteEmbeddingApiV1BridgeEmbeddingsEmbeddingIdDeleteRaw(requestParameters: DeleteEmbeddingApiV1BridgeEmbeddingsEmbeddingIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['embeddingId'] == null) {
            throw new runtime.RequiredError(
                'embeddingId',
                'Required parameter "embeddingId" was null or undefined when calling deleteEmbeddingApiV1BridgeEmbeddingsEmbeddingIdDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/embeddings/{embedding_id}`;
        urlPath = urlPath.replace(`{${"embedding_id"}}`, encodeURIComponent(String(requestParameters['embeddingId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Удалить вектор (только для админов)
     * Delete Embedding
     */
    async deleteEmbeddingApiV1BridgeEmbeddingsEmbeddingIdDelete(requestParameters: DeleteEmbeddingApiV1BridgeEmbeddingsEmbeddingIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deleteEmbeddingApiV1BridgeEmbeddingsEmbeddingIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Удалить связь (только для админов)
     * Delete Link
     */
    async deleteLinkApiV1BridgeLinksLinkIdDeleteRaw(requestParameters: DeleteLinkApiV1BridgeLinksLinkIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['linkId'] == null) {
            throw new runtime.RequiredError(
                'linkId',
                'Required parameter "linkId" was null or undefined when calling deleteLinkApiV1BridgeLinksLinkIdDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/links/{link_id}`;
        urlPath = urlPath.replace(`{${"link_id"}}`, encodeURIComponent(String(requestParameters['linkId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Удалить связь (только для админов)
     * Delete Link
     */
    async deleteLinkApiV1BridgeLinksLinkIdDelete(requestParameters: DeleteLinkApiV1BridgeLinksLinkIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deleteLinkApiV1BridgeLinksLinkIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Удалить правило (только для админов)
     * Delete Rule
     */
    async deleteRuleApiV1BridgeRulesRuleIdDeleteRaw(requestParameters: DeleteRuleApiV1BridgeRulesRuleIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['ruleId'] == null) {
            throw new runtime.RequiredError(
                'ruleId',
                'Required parameter "ruleId" was null or undefined when calling deleteRuleApiV1BridgeRulesRuleIdDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/rules/{rule_id}`;
        urlPath = urlPath.replace(`{${"rule_id"}}`, encodeURIComponent(String(requestParameters['ruleId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Удалить правило (только для админов)
     * Delete Rule
     */
    async deleteRuleApiV1BridgeRulesRuleIdDelete(requestParameters: DeleteRuleApiV1BridgeRulesRuleIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deleteRuleApiV1BridgeRulesRuleIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Обогатить контекст сущности
     * Enrich Context
     */
    async enrichContextApiV1BridgeContextEnrichGetRaw(requestParameters: EnrichContextApiV1BridgeContextEnrichGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['entityType'] == null) {
            throw new runtime.RequiredError(
                'entityType',
                'Required parameter "entityType" was null or undefined when calling enrichContextApiV1BridgeContextEnrichGet().'
            );
        }

        if (requestParameters['entityId'] == null) {
            throw new runtime.RequiredError(
                'entityId',
                'Required parameter "entityId" was null or undefined when calling enrichContextApiV1BridgeContextEnrichGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['entityType'] != null) {
            queryParameters['entity_type'] = requestParameters['entityType'];
        }

        if (requestParameters['entityId'] != null) {
            queryParameters['entity_id'] = requestParameters['entityId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/context/enrich`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Обогатить контекст сущности
     * Enrich Context
     */
    async enrichContextApiV1BridgeContextEnrichGet(requestParameters: EnrichContextApiV1BridgeContextEnrichGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.enrichContextApiV1BridgeContextEnrichGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить все правила
     * Get All Rules
     */
    async getAllRulesApiV1BridgeRulesGetRaw(requestParameters: GetAllRulesApiV1BridgeRulesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        if (requestParameters['isActive'] != null) {
            queryParameters['is_active'] = requestParameters['isActive'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/rules`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить все правила
     * Get All Rules
     */
    async getAllRulesApiV1BridgeRulesGet(requestParameters: GetAllRulesApiV1BridgeRulesGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getAllRulesApiV1BridgeRulesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить аннотацию по ID
     * Get Annotation
     */
    async getAnnotationApiV1BridgeAnnotationsAnnotationIdGetRaw(requestParameters: GetAnnotationApiV1BridgeAnnotationsAnnotationIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['annotationId'] == null) {
            throw new runtime.RequiredError(
                'annotationId',
                'Required parameter "annotationId" was null or undefined when calling getAnnotationApiV1BridgeAnnotationsAnnotationIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/annotations/{annotation_id}`;
        urlPath = urlPath.replace(`{${"annotation_id"}}`, encodeURIComponent(String(requestParameters['annotationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить аннотацию по ID
     * Get Annotation
     */
    async getAnnotationApiV1BridgeAnnotationsAnnotationIdGet(requestParameters: GetAnnotationApiV1BridgeAnnotationsAnnotationIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getAnnotationApiV1BridgeAnnotationsAnnotationIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить статистику по аннотациям
     * Get Annotation Stats
     */
    async getAnnotationStatsApiV1BridgeStatsAnnotationsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/stats/annotations`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить статистику по аннотациям
     * Get Annotation Stats
     */
    async getAnnotationStatsApiV1BridgeStatsAnnotationsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getAnnotationStatsApiV1BridgeStatsAnnotationsGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Получить аннотации для записи знаний
     * Get Annotations By Knowledge Entry
     */
    async getAnnotationsByKnowledgeEntryApiV1BridgeAnnotationsKnowledgeKnowledgeEntryIdGetRaw(requestParameters: GetAnnotationsByKnowledgeEntryApiV1BridgeAnnotationsKnowledgeKnowledgeEntryIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['knowledgeEntryId'] == null) {
            throw new runtime.RequiredError(
                'knowledgeEntryId',
                'Required parameter "knowledgeEntryId" was null or undefined when calling getAnnotationsByKnowledgeEntryApiV1BridgeAnnotationsKnowledgeKnowledgeEntryIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/annotations/knowledge/{knowledge_entry_id}`;
        urlPath = urlPath.replace(`{${"knowledge_entry_id"}}`, encodeURIComponent(String(requestParameters['knowledgeEntryId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить аннотации для записи знаний
     * Get Annotations By Knowledge Entry
     */
    async getAnnotationsByKnowledgeEntryApiV1BridgeAnnotationsKnowledgeKnowledgeEntryIdGet(requestParameters: GetAnnotationsByKnowledgeEntryApiV1BridgeAnnotationsKnowledgeKnowledgeEntryIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getAnnotationsByKnowledgeEntryApiV1BridgeAnnotationsKnowledgeKnowledgeEntryIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить аннотации для цели
     * Get Annotations By Target
     */
    async getAnnotationsByTargetApiV1BridgeAnnotationsTargetTypeTargetIdGetRaw(requestParameters: GetAnnotationsByTargetApiV1BridgeAnnotationsTargetTypeTargetIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['targetType'] == null) {
            throw new runtime.RequiredError(
                'targetType',
                'Required parameter "targetType" was null or undefined when calling getAnnotationsByTargetApiV1BridgeAnnotationsTargetTypeTargetIdGet().'
            );
        }

        if (requestParameters['targetId'] == null) {
            throw new runtime.RequiredError(
                'targetId',
                'Required parameter "targetId" was null or undefined when calling getAnnotationsByTargetApiV1BridgeAnnotationsTargetTypeTargetIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/annotations/{target_type}/{target_id}`;
        urlPath = urlPath.replace(`{${"target_type"}}`, encodeURIComponent(String(requestParameters['targetType'])));
        urlPath = urlPath.replace(`{${"target_id"}}`, encodeURIComponent(String(requestParameters['targetId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить аннотации для цели
     * Get Annotations By Target
     */
    async getAnnotationsByTargetApiV1BridgeAnnotationsTargetTypeTargetIdGet(requestParameters: GetAnnotationsByTargetApiV1BridgeAnnotationsTargetTypeTargetIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getAnnotationsByTargetApiV1BridgeAnnotationsTargetTypeTargetIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить аннотации в определенном диапазоне позиций
     * Get Annotations In Range
     */
    async getAnnotationsInRangeApiV1BridgeAnnotationsRangeTargetTypeTargetIdGetRaw(requestParameters: GetAnnotationsInRangeApiV1BridgeAnnotationsRangeTargetTypeTargetIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['targetType'] == null) {
            throw new runtime.RequiredError(
                'targetType',
                'Required parameter "targetType" was null or undefined when calling getAnnotationsInRangeApiV1BridgeAnnotationsRangeTargetTypeTargetIdGet().'
            );
        }

        if (requestParameters['targetId'] == null) {
            throw new runtime.RequiredError(
                'targetId',
                'Required parameter "targetId" was null or undefined when calling getAnnotationsInRangeApiV1BridgeAnnotationsRangeTargetTypeTargetIdGet().'
            );
        }

        if (requestParameters['startPos'] == null) {
            throw new runtime.RequiredError(
                'startPos',
                'Required parameter "startPos" was null or undefined when calling getAnnotationsInRangeApiV1BridgeAnnotationsRangeTargetTypeTargetIdGet().'
            );
        }

        if (requestParameters['endPos'] == null) {
            throw new runtime.RequiredError(
                'endPos',
                'Required parameter "endPos" was null or undefined when calling getAnnotationsInRangeApiV1BridgeAnnotationsRangeTargetTypeTargetIdGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['startPos'] != null) {
            queryParameters['start_pos'] = requestParameters['startPos'];
        }

        if (requestParameters['endPos'] != null) {
            queryParameters['end_pos'] = requestParameters['endPos'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/annotations/range/{target_type}/{target_id}`;
        urlPath = urlPath.replace(`{${"target_type"}}`, encodeURIComponent(String(requestParameters['targetType'])));
        urlPath = urlPath.replace(`{${"target_id"}}`, encodeURIComponent(String(requestParameters['targetId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить аннотации в определенном диапазоне позиций
     * Get Annotations In Range
     */
    async getAnnotationsInRangeApiV1BridgeAnnotationsRangeTargetTypeTargetIdGet(requestParameters: GetAnnotationsInRangeApiV1BridgeAnnotationsRangeTargetTypeTargetIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getAnnotationsInRangeApiV1BridgeAnnotationsRangeTargetTypeTargetIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить двунаправленные связи между двумя сущностями
     * Get Bidirectional Links
     */
    async getBidirectionalLinksApiV1BridgeLinksBidirectionalEntity1TypeEntity1IdEntity2TypeEntity2IdGetRaw(requestParameters: GetBidirectionalLinksApiV1BridgeLinksBidirectionalEntity1TypeEntity1IdEntity2TypeEntity2IdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['entity1Type'] == null) {
            throw new runtime.RequiredError(
                'entity1Type',
                'Required parameter "entity1Type" was null or undefined when calling getBidirectionalLinksApiV1BridgeLinksBidirectionalEntity1TypeEntity1IdEntity2TypeEntity2IdGet().'
            );
        }

        if (requestParameters['entity1Id'] == null) {
            throw new runtime.RequiredError(
                'entity1Id',
                'Required parameter "entity1Id" was null or undefined when calling getBidirectionalLinksApiV1BridgeLinksBidirectionalEntity1TypeEntity1IdEntity2TypeEntity2IdGet().'
            );
        }

        if (requestParameters['entity2Type'] == null) {
            throw new runtime.RequiredError(
                'entity2Type',
                'Required parameter "entity2Type" was null or undefined when calling getBidirectionalLinksApiV1BridgeLinksBidirectionalEntity1TypeEntity1IdEntity2TypeEntity2IdGet().'
            );
        }

        if (requestParameters['entity2Id'] == null) {
            throw new runtime.RequiredError(
                'entity2Id',
                'Required parameter "entity2Id" was null or undefined when calling getBidirectionalLinksApiV1BridgeLinksBidirectionalEntity1TypeEntity1IdEntity2TypeEntity2IdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/links/bidirectional/{entity1_type}/{entity1_id}/{entity2_type}/{entity2_id}`;
        urlPath = urlPath.replace(`{${"entity1_type"}}`, encodeURIComponent(String(requestParameters['entity1Type'])));
        urlPath = urlPath.replace(`{${"entity1_id"}}`, encodeURIComponent(String(requestParameters['entity1Id'])));
        urlPath = urlPath.replace(`{${"entity2_type"}}`, encodeURIComponent(String(requestParameters['entity2Type'])));
        urlPath = urlPath.replace(`{${"entity2_id"}}`, encodeURIComponent(String(requestParameters['entity2Id'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить двунаправленные связи между двумя сущностями
     * Get Bidirectional Links
     */
    async getBidirectionalLinksApiV1BridgeLinksBidirectionalEntity1TypeEntity1IdEntity2TypeEntity2IdGet(requestParameters: GetBidirectionalLinksApiV1BridgeLinksBidirectionalEntity1TypeEntity1IdEntity2TypeEntity2IdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getBidirectionalLinksApiV1BridgeLinksBidirectionalEntity1TypeEntity1IdEntity2TypeEntity2IdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить вектор для сущности
     * Get Embedding By Entity
     */
    async getEmbeddingByEntityApiV1BridgeEmbeddingsEntityTypeEntityIdGetRaw(requestParameters: GetEmbeddingByEntityApiV1BridgeEmbeddingsEntityTypeEntityIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['entityType'] == null) {
            throw new runtime.RequiredError(
                'entityType',
                'Required parameter "entityType" was null or undefined when calling getEmbeddingByEntityApiV1BridgeEmbeddingsEntityTypeEntityIdGet().'
            );
        }

        if (requestParameters['entityId'] == null) {
            throw new runtime.RequiredError(
                'entityId',
                'Required parameter "entityId" was null or undefined when calling getEmbeddingByEntityApiV1BridgeEmbeddingsEntityTypeEntityIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/embeddings/{entity_type}/{entity_id}`;
        urlPath = urlPath.replace(`{${"entity_type"}}`, encodeURIComponent(String(requestParameters['entityType'])));
        urlPath = urlPath.replace(`{${"entity_id"}}`, encodeURIComponent(String(requestParameters['entityId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить вектор для сущности
     * Get Embedding By Entity
     */
    async getEmbeddingByEntityApiV1BridgeEmbeddingsEntityTypeEntityIdGet(requestParameters: GetEmbeddingByEntityApiV1BridgeEmbeddingsEntityTypeEntityIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getEmbeddingByEntityApiV1BridgeEmbeddingsEntityTypeEntityIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить векторы по модели
     * Get Embeddings By Model
     */
    async getEmbeddingsByModelApiV1BridgeEmbeddingsModelEmbeddingModelGetRaw(requestParameters: GetEmbeddingsByModelApiV1BridgeEmbeddingsModelEmbeddingModelGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['embeddingModel'] == null) {
            throw new runtime.RequiredError(
                'embeddingModel',
                'Required parameter "embeddingModel" was null or undefined when calling getEmbeddingsByModelApiV1BridgeEmbeddingsModelEmbeddingModelGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/embeddings/model/{embedding_model}`;
        urlPath = urlPath.replace(`{${"embedding_model"}}`, encodeURIComponent(String(requestParameters['embeddingModel'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить векторы по модели
     * Get Embeddings By Model
     */
    async getEmbeddingsByModelApiV1BridgeEmbeddingsModelEmbeddingModelGet(requestParameters: GetEmbeddingsByModelApiV1BridgeEmbeddingsModelEmbeddingModelGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getEmbeddingsByModelApiV1BridgeEmbeddingsModelEmbeddingModelGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить граф связей для сущности
     * Get Entity Graph
     */
    async getEntityGraphApiV1BridgeGraphEntityTypeEntityIdGetRaw(requestParameters: GetEntityGraphApiV1BridgeGraphEntityTypeEntityIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['entityType'] == null) {
            throw new runtime.RequiredError(
                'entityType',
                'Required parameter "entityType" was null or undefined when calling getEntityGraphApiV1BridgeGraphEntityTypeEntityIdGet().'
            );
        }

        if (requestParameters['entityId'] == null) {
            throw new runtime.RequiredError(
                'entityId',
                'Required parameter "entityId" was null or undefined when calling getEntityGraphApiV1BridgeGraphEntityTypeEntityIdGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['depth'] != null) {
            queryParameters['depth'] = requestParameters['depth'];
        }

        if (requestParameters['maxLinks'] != null) {
            queryParameters['max_links'] = requestParameters['maxLinks'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/graph/{entity_type}/{entity_id}`;
        urlPath = urlPath.replace(`{${"entity_type"}}`, encodeURIComponent(String(requestParameters['entityType'])));
        urlPath = urlPath.replace(`{${"entity_id"}}`, encodeURIComponent(String(requestParameters['entityId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить граф связей для сущности
     * Get Entity Graph
     */
    async getEntityGraphApiV1BridgeGraphEntityTypeEntityIdGet(requestParameters: GetEntityGraphApiV1BridgeGraphEntityTypeEntityIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getEntityGraphApiV1BridgeGraphEntityTypeEntityIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить связь по ID
     * Get Link
     */
    async getLinkApiV1BridgeLinksLinkIdGetRaw(requestParameters: GetLinkApiV1BridgeLinksLinkIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['linkId'] == null) {
            throw new runtime.RequiredError(
                'linkId',
                'Required parameter "linkId" was null or undefined when calling getLinkApiV1BridgeLinksLinkIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/links/{link_id}`;
        urlPath = urlPath.replace(`{${"link_id"}}`, encodeURIComponent(String(requestParameters['linkId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить связь по ID
     * Get Link
     */
    async getLinkApiV1BridgeLinksLinkIdGet(requestParameters: GetLinkApiV1BridgeLinksLinkIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getLinkApiV1BridgeLinksLinkIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить статистику по связям
     * Get Link Stats
     */
    async getLinkStatsApiV1BridgeStatsLinksGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/stats/links`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить статистику по связям
     * Get Link Stats
     */
    async getLinkStatsApiV1BridgeStatsLinksGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getLinkStatsApiV1BridgeStatsLinksGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Получить все связи от источника
     * Get Links By Source
     */
    async getLinksBySourceApiV1BridgeLinksSourceSourceTypeSourceIdGetRaw(requestParameters: GetLinksBySourceApiV1BridgeLinksSourceSourceTypeSourceIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['sourceType'] == null) {
            throw new runtime.RequiredError(
                'sourceType',
                'Required parameter "sourceType" was null or undefined when calling getLinksBySourceApiV1BridgeLinksSourceSourceTypeSourceIdGet().'
            );
        }

        if (requestParameters['sourceId'] == null) {
            throw new runtime.RequiredError(
                'sourceId',
                'Required parameter "sourceId" was null or undefined when calling getLinksBySourceApiV1BridgeLinksSourceSourceTypeSourceIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/links/source/{source_type}/{source_id}`;
        urlPath = urlPath.replace(`{${"source_type"}}`, encodeURIComponent(String(requestParameters['sourceType'])));
        urlPath = urlPath.replace(`{${"source_id"}}`, encodeURIComponent(String(requestParameters['sourceId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить все связи от источника
     * Get Links By Source
     */
    async getLinksBySourceApiV1BridgeLinksSourceSourceTypeSourceIdGet(requestParameters: GetLinksBySourceApiV1BridgeLinksSourceSourceTypeSourceIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getLinksBySourceApiV1BridgeLinksSourceSourceTypeSourceIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить все связи к цели
     * Get Links By Target
     */
    async getLinksByTargetApiV1BridgeLinksTargetTargetTypeTargetIdGetRaw(requestParameters: GetLinksByTargetApiV1BridgeLinksTargetTargetTypeTargetIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['targetType'] == null) {
            throw new runtime.RequiredError(
                'targetType',
                'Required parameter "targetType" was null or undefined when calling getLinksByTargetApiV1BridgeLinksTargetTargetTypeTargetIdGet().'
            );
        }

        if (requestParameters['targetId'] == null) {
            throw new runtime.RequiredError(
                'targetId',
                'Required parameter "targetId" was null or undefined when calling getLinksByTargetApiV1BridgeLinksTargetTargetTypeTargetIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/links/target/{target_type}/{target_id}`;
        urlPath = urlPath.replace(`{${"target_type"}}`, encodeURIComponent(String(requestParameters['targetType'])));
        urlPath = urlPath.replace(`{${"target_id"}}`, encodeURIComponent(String(requestParameters['targetId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить все связи к цели
     * Get Links By Target
     */
    async getLinksByTargetApiV1BridgeLinksTargetTargetTypeTargetIdGet(requestParameters: GetLinksByTargetApiV1BridgeLinksTargetTargetTypeTargetIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getLinksByTargetApiV1BridgeLinksTargetTargetTypeTargetIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить связи определенного типа
     * Get Links By Type
     */
    async getLinksByTypeApiV1BridgeLinksTypeLinkTypeGetRaw(requestParameters: GetLinksByTypeApiV1BridgeLinksTypeLinkTypeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['linkType'] == null) {
            throw new runtime.RequiredError(
                'linkType',
                'Required parameter "linkType" was null or undefined when calling getLinksByTypeApiV1BridgeLinksTypeLinkTypeGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/links/type/{link_type}`;
        urlPath = urlPath.replace(`{${"link_type"}}`, encodeURIComponent(String(requestParameters['linkType'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить связи определенного типа
     * Get Links By Type
     */
    async getLinksByTypeApiV1BridgeLinksTypeLinkTypeGet(requestParameters: GetLinksByTypeApiV1BridgeLinksTypeLinkTypeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getLinksByTypeApiV1BridgeLinksTypeLinkTypeGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Найти связанное содержимое
     * Get Related Content
     */
    async getRelatedContentApiV1BridgeContextRelatedGetRaw(requestParameters: GetRelatedContentApiV1BridgeContextRelatedGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['fromEntity'] == null) {
            throw new runtime.RequiredError(
                'fromEntity',
                'Required parameter "fromEntity" was null or undefined when calling getRelatedContentApiV1BridgeContextRelatedGet().'
            );
        }

        if (requestParameters['toType'] == null) {
            throw new runtime.RequiredError(
                'toType',
                'Required parameter "toType" was null or undefined when calling getRelatedContentApiV1BridgeContextRelatedGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['fromEntity'] != null) {
            queryParameters['from_entity'] = requestParameters['fromEntity'];
        }

        if (requestParameters['toType'] != null) {
            queryParameters['to_type'] = requestParameters['toType'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/context/related`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Найти связанное содержимое
     * Get Related Content
     */
    async getRelatedContentApiV1BridgeContextRelatedGet(requestParameters: GetRelatedContentApiV1BridgeContextRelatedGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getRelatedContentApiV1BridgeContextRelatedGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Найти связанные сущности
     * Get Related Entities
     */
    async getRelatedEntitiesApiV1BridgeLinksRelatedSourceTypeSourceIdGetRaw(requestParameters: GetRelatedEntitiesApiV1BridgeLinksRelatedSourceTypeSourceIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['sourceType'] == null) {
            throw new runtime.RequiredError(
                'sourceType',
                'Required parameter "sourceType" was null or undefined when calling getRelatedEntitiesApiV1BridgeLinksRelatedSourceTypeSourceIdGet().'
            );
        }

        if (requestParameters['sourceId'] == null) {
            throw new runtime.RequiredError(
                'sourceId',
                'Required parameter "sourceId" was null or undefined when calling getRelatedEntitiesApiV1BridgeLinksRelatedSourceTypeSourceIdGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['targetType'] != null) {
            queryParameters['target_type'] = requestParameters['targetType'];
        }

        if (requestParameters['linkType'] != null) {
            queryParameters['link_type'] = requestParameters['linkType'];
        }

        if (requestParameters['minStrength'] != null) {
            queryParameters['min_strength'] = requestParameters['minStrength'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/links/related/{source_type}/{source_id}`;
        urlPath = urlPath.replace(`{${"source_type"}}`, encodeURIComponent(String(requestParameters['sourceType'])));
        urlPath = urlPath.replace(`{${"source_id"}}`, encodeURIComponent(String(requestParameters['sourceId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Найти связанные сущности
     * Get Related Entities
     */
    async getRelatedEntitiesApiV1BridgeLinksRelatedSourceTypeSourceIdGet(requestParameters: GetRelatedEntitiesApiV1BridgeLinksRelatedSourceTypeSourceIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getRelatedEntitiesApiV1BridgeLinksRelatedSourceTypeSourceIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить правило по ID
     * Get Rule
     */
    async getRuleApiV1BridgeRulesRuleIdGetRaw(requestParameters: GetRuleApiV1BridgeRulesRuleIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['ruleId'] == null) {
            throw new runtime.RequiredError(
                'ruleId',
                'Required parameter "ruleId" was null or undefined when calling getRuleApiV1BridgeRulesRuleIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/rules/{rule_id}`;
        urlPath = urlPath.replace(`{${"rule_id"}}`, encodeURIComponent(String(requestParameters['ruleId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить правило по ID
     * Get Rule
     */
    async getRuleApiV1BridgeRulesRuleIdGet(requestParameters: GetRuleApiV1BridgeRulesRuleIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getRuleApiV1BridgeRulesRuleIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить правила определенного типа
     * Get Rules By Type
     */
    async getRulesByTypeApiV1BridgeRulesTypeRuleTypeGetRaw(requestParameters: GetRulesByTypeApiV1BridgeRulesTypeRuleTypeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['ruleType'] == null) {
            throw new runtime.RequiredError(
                'ruleType',
                'Required parameter "ruleType" was null or undefined when calling getRulesByTypeApiV1BridgeRulesTypeRuleTypeGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/rules/type/{rule_type}`;
        urlPath = urlPath.replace(`{${"rule_type"}}`, encodeURIComponent(String(requestParameters['ruleType'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить правила определенного типа
     * Get Rules By Type
     */
    async getRulesByTypeApiV1BridgeRulesTypeRuleTypeGet(requestParameters: GetRulesByTypeApiV1BridgeRulesTypeRuleTypeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getRulesByTypeApiV1BridgeRulesTypeRuleTypeGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Проверка здоровья API
     * Health Check
     */
    async healthCheckApiV1BridgeHealthGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/health`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Проверка здоровья API
     * Health Check
     */
    async healthCheckApiV1BridgeHealthGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.healthCheckApiV1BridgeHealthGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Предложить связи для сущности (заглушка для будущей реализации)
     * Recommend Links
     */
    async recommendLinksApiV1BridgeRecommendLinksGetRaw(requestParameters: RecommendLinksApiV1BridgeRecommendLinksGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['entityType'] == null) {
            throw new runtime.RequiredError(
                'entityType',
                'Required parameter "entityType" was null or undefined when calling recommendLinksApiV1BridgeRecommendLinksGet().'
            );
        }

        if (requestParameters['entityId'] == null) {
            throw new runtime.RequiredError(
                'entityId',
                'Required parameter "entityId" was null or undefined when calling recommendLinksApiV1BridgeRecommendLinksGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['entityType'] != null) {
            queryParameters['entity_type'] = requestParameters['entityType'];
        }

        if (requestParameters['entityId'] != null) {
            queryParameters['entity_id'] = requestParameters['entityId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/recommend-links`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Предложить связи для сущности (заглушка для будущей реализации)
     * Recommend Links
     */
    async recommendLinksApiV1BridgeRecommendLinksGet(requestParameters: RecommendLinksApiV1BridgeRecommendLinksGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.recommendLinksApiV1BridgeRecommendLinksGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Семантическое сопоставление (заглушка для будущей реализации)
     * Semantic Match
     */
    async semanticMatchApiV1BridgeSemanticMatchPostRaw(requestParameters: SemanticMatchApiV1BridgeSemanticMatchPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['bodySemanticMatchApiV1BridgeSemanticMatchPost'] == null) {
            throw new runtime.RequiredError(
                'bodySemanticMatchApiV1BridgeSemanticMatchPost',
                'Required parameter "bodySemanticMatchApiV1BridgeSemanticMatchPost" was null or undefined when calling semanticMatchApiV1BridgeSemanticMatchPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/semantic-match`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BodySemanticMatchApiV1BridgeSemanticMatchPostToJSON(requestParameters['bodySemanticMatchApiV1BridgeSemanticMatchPost']),
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Семантическое сопоставление (заглушка для будущей реализации)
     * Semantic Match
     */
    async semanticMatchApiV1BridgeSemanticMatchPost(requestParameters: SemanticMatchApiV1BridgeSemanticMatchPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.semanticMatchApiV1BridgeSemanticMatchPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Предложить возможные связи на основе существующих паттернов
     * Suggest Links
     */
    async suggestLinksApiV1BridgeSuggestLinksSourceTypeSourceIdGetRaw(requestParameters: SuggestLinksApiV1BridgeSuggestLinksSourceTypeSourceIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['sourceType'] == null) {
            throw new runtime.RequiredError(
                'sourceType',
                'Required parameter "sourceType" was null or undefined when calling suggestLinksApiV1BridgeSuggestLinksSourceTypeSourceIdGet().'
            );
        }

        if (requestParameters['sourceId'] == null) {
            throw new runtime.RequiredError(
                'sourceId',
                'Required parameter "sourceId" was null or undefined when calling suggestLinksApiV1BridgeSuggestLinksSourceTypeSourceIdGet().'
            );
        }

        if (requestParameters['targetType'] == null) {
            throw new runtime.RequiredError(
                'targetType',
                'Required parameter "targetType" was null or undefined when calling suggestLinksApiV1BridgeSuggestLinksSourceTypeSourceIdGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['targetType'] != null) {
            queryParameters['target_type'] = requestParameters['targetType'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/suggest-links/{source_type}/{source_id}`;
        urlPath = urlPath.replace(`{${"source_type"}}`, encodeURIComponent(String(requestParameters['sourceType'])));
        urlPath = urlPath.replace(`{${"source_id"}}`, encodeURIComponent(String(requestParameters['sourceId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Предложить возможные связи на основе существующих паттернов
     * Suggest Links
     */
    async suggestLinksApiV1BridgeSuggestLinksSourceTypeSourceIdGet(requestParameters: SuggestLinksApiV1BridgeSuggestLinksSourceTypeSourceIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.suggestLinksApiV1BridgeSuggestLinksSourceTypeSourceIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Обновить аннотацию (только для админов)
     * Update Annotation
     */
    async updateAnnotationApiV1BridgeAnnotationsAnnotationIdPutRaw(requestParameters: UpdateAnnotationApiV1BridgeAnnotationsAnnotationIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['annotationId'] == null) {
            throw new runtime.RequiredError(
                'annotationId',
                'Required parameter "annotationId" was null or undefined when calling updateAnnotationApiV1BridgeAnnotationsAnnotationIdPut().'
            );
        }

        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling updateAnnotationApiV1BridgeAnnotationsAnnotationIdPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/annotations/{annotation_id}`;
        urlPath = urlPath.replace(`{${"annotation_id"}}`, encodeURIComponent(String(requestParameters['annotationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Обновить аннотацию (только для админов)
     * Update Annotation
     */
    async updateAnnotationApiV1BridgeAnnotationsAnnotationIdPut(requestParameters: UpdateAnnotationApiV1BridgeAnnotationsAnnotationIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.updateAnnotationApiV1BridgeAnnotationsAnnotationIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Обновить вектор (только для админов)
     * Update Embedding
     */
    async updateEmbeddingApiV1BridgeEmbeddingsEmbeddingIdPutRaw(requestParameters: UpdateEmbeddingApiV1BridgeEmbeddingsEmbeddingIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['embeddingId'] == null) {
            throw new runtime.RequiredError(
                'embeddingId',
                'Required parameter "embeddingId" was null or undefined when calling updateEmbeddingApiV1BridgeEmbeddingsEmbeddingIdPut().'
            );
        }

        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling updateEmbeddingApiV1BridgeEmbeddingsEmbeddingIdPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/embeddings/{embedding_id}`;
        urlPath = urlPath.replace(`{${"embedding_id"}}`, encodeURIComponent(String(requestParameters['embeddingId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Обновить вектор (только для админов)
     * Update Embedding
     */
    async updateEmbeddingApiV1BridgeEmbeddingsEmbeddingIdPut(requestParameters: UpdateEmbeddingApiV1BridgeEmbeddingsEmbeddingIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.updateEmbeddingApiV1BridgeEmbeddingsEmbeddingIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Обновить связь (только для админов)
     * Update Link
     */
    async updateLinkApiV1BridgeLinksLinkIdPutRaw(requestParameters: UpdateLinkApiV1BridgeLinksLinkIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['linkId'] == null) {
            throw new runtime.RequiredError(
                'linkId',
                'Required parameter "linkId" was null or undefined when calling updateLinkApiV1BridgeLinksLinkIdPut().'
            );
        }

        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling updateLinkApiV1BridgeLinksLinkIdPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/links/{link_id}`;
        urlPath = urlPath.replace(`{${"link_id"}}`, encodeURIComponent(String(requestParameters['linkId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Обновить связь (только для админов)
     * Update Link
     */
    async updateLinkApiV1BridgeLinksLinkIdPut(requestParameters: UpdateLinkApiV1BridgeLinksLinkIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.updateLinkApiV1BridgeLinksLinkIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Обновить правило (только для админов)
     * Update Rule
     */
    async updateRuleApiV1BridgeRulesRuleIdPutRaw(requestParameters: UpdateRuleApiV1BridgeRulesRuleIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['ruleId'] == null) {
            throw new runtime.RequiredError(
                'ruleId',
                'Required parameter "ruleId" was null or undefined when calling updateRuleApiV1BridgeRulesRuleIdPut().'
            );
        }

        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling updateRuleApiV1BridgeRulesRuleIdPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/bridge/rules/{rule_id}`;
        urlPath = urlPath.replace(`{${"rule_id"}}`, encodeURIComponent(String(requestParameters['ruleId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Обновить правило (только для админов)
     * Update Rule
     */
    async updateRuleApiV1BridgeRulesRuleIdPut(requestParameters: UpdateRuleApiV1BridgeRulesRuleIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.updateRuleApiV1BridgeRulesRuleIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
