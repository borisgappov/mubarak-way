/* tslint:disable */
/* eslint-disable */
/**
 * Платформа Духовных Практик Gateway API
 *          ## Публичный REST API шлюз для платформы духовных практик                  ### Аутентификация         Все эндпоинты (кроме `/api/v1/auth/_*`) требуют JWT Bearer токен в заголовке Authorization.                  ### Основные возможности:         - **Цели (Goals)**: Управление духовными целями пользователей         - **Тасбих (Tasbih)**: Счетчик для духовных практик         - **Азкары (Azkar)**: Ежедневные поминания         - **Quran API**: Работа с Кораном, переводами и аудио         - **Библиотека**: Управление пользовательским контентом         - **Отчеты**: Генерация отчетов о духовной активности                  ### Статус коды:         - `200` - Успешный запрос         - `201` - Ресурс создан         - `400` - Неверный формат запроса         - `401` - Требуется авторизация         - `403` - Доступ запрещен         - `404` - Ресурс не найден         - `422` - Ошибка валидации данных         - `500` - Внутренняя ошибка сервера         - `503` - Сервис недоступен                  ### Health Checks:         - `GET /health` - Базовый health check         - `GET /health/ready` - Readiness probe (Kubernetes)         - `GET /health/live` - Liveness probe (Kubernetes)         - `GET /metrics` - Prometheus метрики         
 *
 * The version of the OpenAPI document: 1.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DailyReport,
  HTTPValidationError,
  MonthlyReport,
  RawDataReport,
} from '../models/index';
import {
    DailyReportFromJSON,
    DailyReportToJSON,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    MonthlyReportFromJSON,
    MonthlyReportToJSON,
    RawDataReportFromJSON,
    RawDataReportToJSON,
} from '../models/index';

export interface CreateDailyReportApiV1ReportsDailyPostRequest {
    dailyReport: DailyReport;
}

export interface DeleteDailyReportApiV1ReportsDailyDateDeleteRequest {
    date: string;
}

export interface GetActivityHistoryApiV1ReportsHistoryGetRequest {
    days?: number;
}

export interface GetMonthlyReportApiV1ReportsMonthlyGetRequest {
    month: string;
    tz?: string;
}

export interface GetRawDataReportApiV1ReportsRawGetRequest {
    startDate: string;
    endDate: string;
    tz?: string;
    format?: string;
}

export interface UpdateDailyReportApiV1ReportsDailyDatePutRequest {
    date: string;
    dailyReport: DailyReport;
}

/**
 * ReportsApi - interface
 * 
 * @export
 * @interface ReportsApiInterface
 */
export interface ReportsApiInterface {
    /**
     * Создать ежедневный отчет
     * @summary Create Daily Report
     * @param {DailyReport} dailyReport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    createDailyReportApiV1ReportsDailyPostRaw(requestParameters: CreateDailyReportApiV1ReportsDailyPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DailyReport>>;

    /**
     * Создать ежедневный отчет
     * Create Daily Report
     */
    createDailyReportApiV1ReportsDailyPost(requestParameters: CreateDailyReportApiV1ReportsDailyPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DailyReport>;

    /**
     * Удалить ежедневный отчет
     * @summary Delete Daily Report
     * @param {string} date 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    deleteDailyReportApiV1ReportsDailyDateDeleteRaw(requestParameters: DeleteDailyReportApiV1ReportsDailyDateDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Удалить ежедневный отчет
     * Delete Daily Report
     */
    deleteDailyReportApiV1ReportsDailyDateDelete(requestParameters: DeleteDailyReportApiV1ReportsDailyDateDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить историю активности за последние N дней
     * @summary Get Activity History
     * @param {number} [days] Количество дней
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    getActivityHistoryApiV1ReportsHistoryGetRaw(requestParameters: GetActivityHistoryApiV1ReportsHistoryGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить историю активности за последние N дней
     * Get Activity History
     */
    getActivityHistoryApiV1ReportsHistoryGet(requestParameters: GetActivityHistoryApiV1ReportsHistoryGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить дневную статистику за сегодня
     * @summary Get Daily Report
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    getDailyReportApiV1ReportsDailyGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить дневную статистику за сегодня
     * Get Daily Report
     */
    getDailyReportApiV1ReportsDailyGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Get monthly report
     * @summary Get Monthly Report
     * @param {string} month Month (YYYY-MM)
     * @param {string} [tz] Timezone (IANA format)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    getMonthlyReportApiV1ReportsMonthlyGetRaw(requestParameters: GetMonthlyReportApiV1ReportsMonthlyGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MonthlyReport>>;

    /**
     * Get monthly report
     * Get Monthly Report
     */
    getMonthlyReportApiV1ReportsMonthlyGet(requestParameters: GetMonthlyReportApiV1ReportsMonthlyGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MonthlyReport>;

    /**
     * Get raw data report
     * @summary Get Raw Data Report
     * @param {string} startDate Start date (YYYY-MM-DD)
     * @param {string} endDate End date (YYYY-MM-DD)
     * @param {string} [tz] Timezone (IANA format)
     * @param {string} [format] Export format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    getRawDataReportApiV1ReportsRawGetRaw(requestParameters: GetRawDataReportApiV1ReportsRawGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RawDataReport>>;

    /**
     * Get raw data report
     * Get Raw Data Report
     */
    getRawDataReportApiV1ReportsRawGet(requestParameters: GetRawDataReportApiV1ReportsRawGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RawDataReport>;

    /**
     * Получить все серии дней подряд пользователя
     * @summary Get User Streaks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    getUserStreaksApiV1ReportsStreaksGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить все серии дней подряд пользователя
     * Get User Streaks
     */
    getUserStreaksApiV1ReportsStreaksGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить общую статистику пользователя
     * @summary Get User Summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    getUserSummaryApiV1ReportsSummaryGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить общую статистику пользователя
     * Get User Summary
     */
    getUserSummaryApiV1ReportsSummaryGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Обновить ежедневный отчет
     * @summary Update Daily Report
     * @param {string} date 
     * @param {DailyReport} dailyReport 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApiInterface
     */
    updateDailyReportApiV1ReportsDailyDatePutRaw(requestParameters: UpdateDailyReportApiV1ReportsDailyDatePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DailyReport>>;

    /**
     * Обновить ежедневный отчет
     * Update Daily Report
     */
    updateDailyReportApiV1ReportsDailyDatePut(requestParameters: UpdateDailyReportApiV1ReportsDailyDatePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DailyReport>;

}

/**
 * 
 */
export class ReportsApi extends runtime.BaseAPI implements ReportsApiInterface {

    /**
     * Создать ежедневный отчет
     * Create Daily Report
     */
    async createDailyReportApiV1ReportsDailyPostRaw(requestParameters: CreateDailyReportApiV1ReportsDailyPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DailyReport>> {
        if (requestParameters['dailyReport'] == null) {
            throw new runtime.RequiredError(
                'dailyReport',
                'Required parameter "dailyReport" was null or undefined when calling createDailyReportApiV1ReportsDailyPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/reports/daily`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DailyReportToJSON(requestParameters['dailyReport']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DailyReportFromJSON(jsonValue));
    }

    /**
     * Создать ежедневный отчет
     * Create Daily Report
     */
    async createDailyReportApiV1ReportsDailyPost(requestParameters: CreateDailyReportApiV1ReportsDailyPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DailyReport> {
        const response = await this.createDailyReportApiV1ReportsDailyPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Удалить ежедневный отчет
     * Delete Daily Report
     */
    async deleteDailyReportApiV1ReportsDailyDateDeleteRaw(requestParameters: DeleteDailyReportApiV1ReportsDailyDateDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['date'] == null) {
            throw new runtime.RequiredError(
                'date',
                'Required parameter "date" was null or undefined when calling deleteDailyReportApiV1ReportsDailyDateDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/reports/daily/{date}`;
        urlPath = urlPath.replace(`{${"date"}}`, encodeURIComponent(String(requestParameters['date'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Удалить ежедневный отчет
     * Delete Daily Report
     */
    async deleteDailyReportApiV1ReportsDailyDateDelete(requestParameters: DeleteDailyReportApiV1ReportsDailyDateDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deleteDailyReportApiV1ReportsDailyDateDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить историю активности за последние N дней
     * Get Activity History
     */
    async getActivityHistoryApiV1ReportsHistoryGetRaw(requestParameters: GetActivityHistoryApiV1ReportsHistoryGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        if (requestParameters['days'] != null) {
            queryParameters['days'] = requestParameters['days'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/reports/history`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить историю активности за последние N дней
     * Get Activity History
     */
    async getActivityHistoryApiV1ReportsHistoryGet(requestParameters: GetActivityHistoryApiV1ReportsHistoryGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getActivityHistoryApiV1ReportsHistoryGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить дневную статистику за сегодня
     * Get Daily Report
     */
    async getDailyReportApiV1ReportsDailyGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/reports/daily`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить дневную статистику за сегодня
     * Get Daily Report
     */
    async getDailyReportApiV1ReportsDailyGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getDailyReportApiV1ReportsDailyGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get monthly report
     * Get Monthly Report
     */
    async getMonthlyReportApiV1ReportsMonthlyGetRaw(requestParameters: GetMonthlyReportApiV1ReportsMonthlyGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<MonthlyReport>> {
        if (requestParameters['month'] == null) {
            throw new runtime.RequiredError(
                'month',
                'Required parameter "month" was null or undefined when calling getMonthlyReportApiV1ReportsMonthlyGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['month'] != null) {
            queryParameters['month'] = requestParameters['month'];
        }

        if (requestParameters['tz'] != null) {
            queryParameters['tz'] = requestParameters['tz'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/reports/monthly`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => MonthlyReportFromJSON(jsonValue));
    }

    /**
     * Get monthly report
     * Get Monthly Report
     */
    async getMonthlyReportApiV1ReportsMonthlyGet(requestParameters: GetMonthlyReportApiV1ReportsMonthlyGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<MonthlyReport> {
        const response = await this.getMonthlyReportApiV1ReportsMonthlyGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get raw data report
     * Get Raw Data Report
     */
    async getRawDataReportApiV1ReportsRawGetRaw(requestParameters: GetRawDataReportApiV1ReportsRawGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RawDataReport>> {
        if (requestParameters['startDate'] == null) {
            throw new runtime.RequiredError(
                'startDate',
                'Required parameter "startDate" was null or undefined when calling getRawDataReportApiV1ReportsRawGet().'
            );
        }

        if (requestParameters['endDate'] == null) {
            throw new runtime.RequiredError(
                'endDate',
                'Required parameter "endDate" was null or undefined when calling getRawDataReportApiV1ReportsRawGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['startDate'] != null) {
            queryParameters['start_date'] = requestParameters['startDate'];
        }

        if (requestParameters['endDate'] != null) {
            queryParameters['end_date'] = requestParameters['endDate'];
        }

        if (requestParameters['tz'] != null) {
            queryParameters['tz'] = requestParameters['tz'];
        }

        if (requestParameters['format'] != null) {
            queryParameters['format'] = requestParameters['format'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/reports/raw`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RawDataReportFromJSON(jsonValue));
    }

    /**
     * Get raw data report
     * Get Raw Data Report
     */
    async getRawDataReportApiV1ReportsRawGet(requestParameters: GetRawDataReportApiV1ReportsRawGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RawDataReport> {
        const response = await this.getRawDataReportApiV1ReportsRawGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить все серии дней подряд пользователя
     * Get User Streaks
     */
    async getUserStreaksApiV1ReportsStreaksGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/reports/streaks`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить все серии дней подряд пользователя
     * Get User Streaks
     */
    async getUserStreaksApiV1ReportsStreaksGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getUserStreaksApiV1ReportsStreaksGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Получить общую статистику пользователя
     * Get User Summary
     */
    async getUserSummaryApiV1ReportsSummaryGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/reports/summary`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить общую статистику пользователя
     * Get User Summary
     */
    async getUserSummaryApiV1ReportsSummaryGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getUserSummaryApiV1ReportsSummaryGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Обновить ежедневный отчет
     * Update Daily Report
     */
    async updateDailyReportApiV1ReportsDailyDatePutRaw(requestParameters: UpdateDailyReportApiV1ReportsDailyDatePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DailyReport>> {
        if (requestParameters['date'] == null) {
            throw new runtime.RequiredError(
                'date',
                'Required parameter "date" was null or undefined when calling updateDailyReportApiV1ReportsDailyDatePut().'
            );
        }

        if (requestParameters['dailyReport'] == null) {
            throw new runtime.RequiredError(
                'dailyReport',
                'Required parameter "dailyReport" was null or undefined when calling updateDailyReportApiV1ReportsDailyDatePut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/reports/daily/{date}`;
        urlPath = urlPath.replace(`{${"date"}}`, encodeURIComponent(String(requestParameters['date'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: DailyReportToJSON(requestParameters['dailyReport']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DailyReportFromJSON(jsonValue));
    }

    /**
     * Обновить ежедневный отчет
     * Update Daily Report
     */
    async updateDailyReportApiV1ReportsDailyDatePut(requestParameters: UpdateDailyReportApiV1ReportsDailyDatePutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DailyReport> {
        const response = await this.updateDailyReportApiV1ReportsDailyDatePutRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
