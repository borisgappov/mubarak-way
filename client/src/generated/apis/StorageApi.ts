/* tslint:disable */
/* eslint-disable */
/**
 * Платформа Духовных Практик Gateway API
 *          ## Публичный REST API шлюз для платформы духовных практик                  ### Аутентификация         Все эндпоинты (кроме `/api/v1/auth/_*`) требуют JWT Bearer токен в заголовке Authorization.                  ### Основные возможности:         - **Цели (Goals)**: Управление духовными целями пользователей         - **Тасбих (Tasbih)**: Счетчик для духовных практик         - **Азкары (Azkar)**: Ежедневные поминания         - **Quran API**: Работа с Кораном, переводами и аудио         - **Библиотека**: Управление пользовательским контентом         - **Отчеты**: Генерация отчетов о духовной активности                  ### Статус коды:         - `200` - Успешный запрос         - `201` - Ресурс создан         - `400` - Неверный формат запроса         - `401` - Требуется авторизация         - `403` - Доступ запрещен         - `404` - Ресурс не найден         - `422` - Ошибка валидации данных         - `500` - Внутренняя ошибка сервера         - `503` - Сервис недоступен                  ### Health Checks:         - `GET /health` - Базовый health check         - `GET /health/ready` - Readiness probe (Kubernetes)         - `GET /health/live` - Liveness probe (Kubernetes)         - `GET /metrics` - Prometheus метрики         
 *
 * The version of the OpenAPI document: 1.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  DeleteResponse,
  HTTPValidationError,
  HealthResponse,
  ObjectInfo,
  ObjectListResponse,
  PresignedUrlResponse,
  UploadResponse,
} from '../models/index';
import {
    DeleteResponseFromJSON,
    DeleteResponseToJSON,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    HealthResponseFromJSON,
    HealthResponseToJSON,
    ObjectInfoFromJSON,
    ObjectInfoToJSON,
    ObjectListResponseFromJSON,
    ObjectListResponseToJSON,
    PresignedUrlResponseFromJSON,
    PresignedUrlResponseToJSON,
    UploadResponseFromJSON,
    UploadResponseToJSON,
} from '../models/index';

export interface DeleteObjectApiV1StorageBucketPathDeleteRequest {
    bucket: string;
    path: string;
}

export interface DeleteObjectApiV1StorageBucketPathDelete0Request {
    bucket: string;
    path: string;
}

export interface DownloadFileApiV1StorageDownloadBucketPathGetRequest {
    bucket: string;
    path: string;
}

export interface DownloadFileApiV1StorageDownloadBucketPathGet0Request {
    bucket: string;
    path: string;
}

export interface GetArabicAudioApiV1StorageArabicLessonsAudioLetterFormGetRequest {
    letter: string;
    form: string;
    expires?: number;
}

export interface GetArabicAudioApiV1StorageArabicLessonsAudioLetterFormGet0Request {
    letter: string;
    form: string;
    expires?: number;
}

export interface GetArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGetRequest {
    letter: string;
    category: string;
    filename: string;
    expires?: number;
}

export interface GetArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGet0Request {
    letter: string;
    category: string;
    filename: string;
    expires?: number;
}

export interface GetObjectInfoApiV1StorageInfoBucketPathGetRequest {
    bucket: string;
    path: string;
}

export interface GetObjectInfoApiV1StorageInfoBucketPathGet0Request {
    bucket: string;
    path: string;
}

export interface GetPresignedUrlApiV1StorageUrlBucketPathGetRequest {
    bucket: string;
    path: string;
    expires?: number;
}

export interface GetPresignedUrlApiV1StorageUrlBucketPathGet0Request {
    bucket: string;
    path: string;
    expires?: number;
}

export interface GetUserRecordingsApiV1StorageArabicLessonsRecordingsGetRequest {
    lessonId?: string | null;
    limit?: number;
}

export interface GetUserRecordingsApiV1StorageArabicLessonsRecordingsGet0Request {
    lessonId?: string | null;
    limit?: number;
}

export interface ListObjectsApiV1StorageListBucketGetRequest {
    bucket: string;
    prefix?: string | null;
    limit?: number;
}

export interface ListObjectsApiV1StorageListBucketGet0Request {
    bucket: string;
    prefix?: string | null;
    limit?: number;
}

export interface UploadFileApiV1StorageUploadPostRequest {
    bucket: string;
    file: Blob;
    path?: string | null;
}

export interface UploadFileApiV1StorageUploadPost0Request {
    bucket: string;
    file: Blob;
    path?: string | null;
}

export interface UploadRecordingApiV1StorageArabicLessonsRecordingPostRequest {
    lessonId: string;
    file: Blob;
}

export interface UploadRecordingApiV1StorageArabicLessonsRecordingPost0Request {
    lessonId: string;
    file: Blob;
}

/**
 * StorageApi - interface
 * 
 * @export
 * @interface StorageApiInterface
 */
export interface StorageApiInterface {
    /**
     * Delete an object from storage.  - **bucket**: Bucket name - **path**: Object path  For user-recordings, only the owner can delete.
     * @summary Delete Object
     * @param {string} bucket 
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    deleteObjectApiV1StorageBucketPathDeleteRaw(requestParameters: DeleteObjectApiV1StorageBucketPathDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteResponse>>;

    /**
     * Delete an object from storage.  - **bucket**: Bucket name - **path**: Object path  For user-recordings, only the owner can delete.
     * Delete Object
     */
    deleteObjectApiV1StorageBucketPathDelete(requestParameters: DeleteObjectApiV1StorageBucketPathDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteResponse>;

    /**
     * Delete an object from storage.  - **bucket**: Bucket name - **path**: Object path  For user-recordings, only the owner can delete.
     * @summary Delete Object
     * @param {string} bucket 
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    deleteObjectApiV1StorageBucketPathDelete_1Raw(requestParameters: DeleteObjectApiV1StorageBucketPathDelete0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteResponse>>;

    /**
     * Delete an object from storage.  - **bucket**: Bucket name - **path**: Object path  For user-recordings, only the owner can delete.
     * Delete Object
     */
    deleteObjectApiV1StorageBucketPathDelete_1(requestParameters: DeleteObjectApiV1StorageBucketPathDelete0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteResponse>;

    /**
     * Download a file from storage.  Returns file content as binary stream.  - **bucket**: Source bucket - **path**: Object path in bucket
     * @summary Download File
     * @param {string} bucket 
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    downloadFileApiV1StorageDownloadBucketPathGetRaw(requestParameters: DownloadFileApiV1StorageDownloadBucketPathGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Download a file from storage.  Returns file content as binary stream.  - **bucket**: Source bucket - **path**: Object path in bucket
     * Download File
     */
    downloadFileApiV1StorageDownloadBucketPathGet(requestParameters: DownloadFileApiV1StorageDownloadBucketPathGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Download a file from storage.  Returns file content as binary stream.  - **bucket**: Source bucket - **path**: Object path in bucket
     * @summary Download File
     * @param {string} bucket 
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    downloadFileApiV1StorageDownloadBucketPathGet_2Raw(requestParameters: DownloadFileApiV1StorageDownloadBucketPathGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Download a file from storage.  Returns file content as binary stream.  - **bucket**: Source bucket - **path**: Object path in bucket
     * Download File
     */
    downloadFileApiV1StorageDownloadBucketPathGet_2(requestParameters: DownloadFileApiV1StorageDownloadBucketPathGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Get Arabic letter audio URL.  - **letter**: Letter name (alif, ba, ta, ...) - **form**: Form (isolated, initial, medial, final, name, sound, pronunciation) - **expires**: URL expiration in seconds
     * @summary Get Arabic Audio
     * @param {string} letter 
     * @param {string} form 
     * @param {number} [expires] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    getArabicAudioApiV1StorageArabicLessonsAudioLetterFormGetRaw(requestParameters: GetArabicAudioApiV1StorageArabicLessonsAudioLetterFormGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Get Arabic letter audio URL.  - **letter**: Letter name (alif, ba, ta, ...) - **form**: Form (isolated, initial, medial, final, name, sound, pronunciation) - **expires**: URL expiration in seconds
     * Get Arabic Audio
     */
    getArabicAudioApiV1StorageArabicLessonsAudioLetterFormGet(requestParameters: GetArabicAudioApiV1StorageArabicLessonsAudioLetterFormGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Get Arabic letter audio URL.  - **letter**: Letter name (alif, ba, ta, ...) - **form**: Form (isolated, initial, medial, final, name, sound, pronunciation) - **expires**: URL expiration in seconds
     * @summary Get Arabic Audio
     * @param {string} letter 
     * @param {string} form 
     * @param {number} [expires] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    getArabicAudioApiV1StorageArabicLessonsAudioLetterFormGet_3Raw(requestParameters: GetArabicAudioApiV1StorageArabicLessonsAudioLetterFormGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Get Arabic letter audio URL.  - **letter**: Letter name (alif, ba, ta, ...) - **form**: Form (isolated, initial, medial, final, name, sound, pronunciation) - **expires**: URL expiration in seconds
     * Get Arabic Audio
     */
    getArabicAudioApiV1StorageArabicLessonsAudioLetterFormGet_3(requestParameters: GetArabicAudioApiV1StorageArabicLessonsAudioLetterFormGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Get Arabic letter image URL.  - **letter**: Letter name - **category**: Category (standalone, in_word, diacritics) - **filename**: Image filename - **expires**: URL expiration in seconds
     * @summary Get Arabic Image
     * @param {string} letter 
     * @param {string} category 
     * @param {string} filename 
     * @param {number} [expires] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    getArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGetRaw(requestParameters: GetArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Get Arabic letter image URL.  - **letter**: Letter name - **category**: Category (standalone, in_word, diacritics) - **filename**: Image filename - **expires**: URL expiration in seconds
     * Get Arabic Image
     */
    getArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGet(requestParameters: GetArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Get Arabic letter image URL.  - **letter**: Letter name - **category**: Category (standalone, in_word, diacritics) - **filename**: Image filename - **expires**: URL expiration in seconds
     * @summary Get Arabic Image
     * @param {string} letter 
     * @param {string} category 
     * @param {string} filename 
     * @param {number} [expires] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    getArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGet_4Raw(requestParameters: GetArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Get Arabic letter image URL.  - **letter**: Letter name - **category**: Category (standalone, in_word, diacritics) - **filename**: Image filename - **expires**: URL expiration in seconds
     * Get Arabic Image
     */
    getArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGet_4(requestParameters: GetArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Get object metadata.  - **bucket**: Bucket name - **path**: Object path  Returns object size, content type, and other metadata.
     * @summary Get Object Info
     * @param {string} bucket 
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    getObjectInfoApiV1StorageInfoBucketPathGetRaw(requestParameters: GetObjectInfoApiV1StorageInfoBucketPathGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ObjectInfo>>;

    /**
     * Get object metadata.  - **bucket**: Bucket name - **path**: Object path  Returns object size, content type, and other metadata.
     * Get Object Info
     */
    getObjectInfoApiV1StorageInfoBucketPathGet(requestParameters: GetObjectInfoApiV1StorageInfoBucketPathGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ObjectInfo>;

    /**
     * Get object metadata.  - **bucket**: Bucket name - **path**: Object path  Returns object size, content type, and other metadata.
     * @summary Get Object Info
     * @param {string} bucket 
     * @param {string} path 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    getObjectInfoApiV1StorageInfoBucketPathGet_5Raw(requestParameters: GetObjectInfoApiV1StorageInfoBucketPathGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ObjectInfo>>;

    /**
     * Get object metadata.  - **bucket**: Bucket name - **path**: Object path  Returns object size, content type, and other metadata.
     * Get Object Info
     */
    getObjectInfoApiV1StorageInfoBucketPathGet_5(requestParameters: GetObjectInfoApiV1StorageInfoBucketPathGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ObjectInfo>;

    /**
     * Get presigned URL for file access.  Returns a temporary URL valid for the specified duration.  - **bucket**: Bucket name - **path**: Object path - **expires**: URL expiration in seconds (60-86400)
     * @summary Get Presigned Url
     * @param {string} bucket 
     * @param {string} path 
     * @param {number} [expires] Expiration in seconds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    getPresignedUrlApiV1StorageUrlBucketPathGetRaw(requestParameters: GetPresignedUrlApiV1StorageUrlBucketPathGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PresignedUrlResponse>>;

    /**
     * Get presigned URL for file access.  Returns a temporary URL valid for the specified duration.  - **bucket**: Bucket name - **path**: Object path - **expires**: URL expiration in seconds (60-86400)
     * Get Presigned Url
     */
    getPresignedUrlApiV1StorageUrlBucketPathGet(requestParameters: GetPresignedUrlApiV1StorageUrlBucketPathGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PresignedUrlResponse>;

    /**
     * Get presigned URL for file access.  Returns a temporary URL valid for the specified duration.  - **bucket**: Bucket name - **path**: Object path - **expires**: URL expiration in seconds (60-86400)
     * @summary Get Presigned Url
     * @param {string} bucket 
     * @param {string} path 
     * @param {number} [expires] Expiration in seconds
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    getPresignedUrlApiV1StorageUrlBucketPathGet_6Raw(requestParameters: GetPresignedUrlApiV1StorageUrlBucketPathGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PresignedUrlResponse>>;

    /**
     * Get presigned URL for file access.  Returns a temporary URL valid for the specified duration.  - **bucket**: Bucket name - **path**: Object path - **expires**: URL expiration in seconds (60-86400)
     * Get Presigned Url
     */
    getPresignedUrlApiV1StorageUrlBucketPathGet_6(requestParameters: GetPresignedUrlApiV1StorageUrlBucketPathGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PresignedUrlResponse>;

    /**
     * Get user\'s recordings.  - **lesson_id**: Optional lesson filter - **limit**: Maximum recordings to return  Returns list of recordings with presigned URLs.
     * @summary Get User Recordings
     * @param {string} [lessonId] Filter by lesson
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    getUserRecordingsApiV1StorageArabicLessonsRecordingsGetRaw(requestParameters: GetUserRecordingsApiV1StorageArabicLessonsRecordingsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Get user\'s recordings.  - **lesson_id**: Optional lesson filter - **limit**: Maximum recordings to return  Returns list of recordings with presigned URLs.
     * Get User Recordings
     */
    getUserRecordingsApiV1StorageArabicLessonsRecordingsGet(requestParameters: GetUserRecordingsApiV1StorageArabicLessonsRecordingsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Get user\'s recordings.  - **lesson_id**: Optional lesson filter - **limit**: Maximum recordings to return  Returns list of recordings with presigned URLs.
     * @summary Get User Recordings
     * @param {string} [lessonId] Filter by lesson
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    getUserRecordingsApiV1StorageArabicLessonsRecordingsGet_7Raw(requestParameters: GetUserRecordingsApiV1StorageArabicLessonsRecordingsGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Get user\'s recordings.  - **lesson_id**: Optional lesson filter - **limit**: Maximum recordings to return  Returns list of recordings with presigned URLs.
     * Get User Recordings
     */
    getUserRecordingsApiV1StorageArabicLessonsRecordingsGet_7(requestParameters: GetUserRecordingsApiV1StorageArabicLessonsRecordingsGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * List objects in a bucket.  - **bucket**: Bucket name - **prefix**: Filter objects by prefix - **limit**: Maximum number of objects to return
     * @summary List Objects
     * @param {string} bucket 
     * @param {string} [prefix] Filter by prefix
     * @param {number} [limit] Max objects to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    listObjectsApiV1StorageListBucketGetRaw(requestParameters: ListObjectsApiV1StorageListBucketGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ObjectListResponse>>;

    /**
     * List objects in a bucket.  - **bucket**: Bucket name - **prefix**: Filter objects by prefix - **limit**: Maximum number of objects to return
     * List Objects
     */
    listObjectsApiV1StorageListBucketGet(requestParameters: ListObjectsApiV1StorageListBucketGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ObjectListResponse>;

    /**
     * List objects in a bucket.  - **bucket**: Bucket name - **prefix**: Filter objects by prefix - **limit**: Maximum number of objects to return
     * @summary List Objects
     * @param {string} bucket 
     * @param {string} [prefix] Filter by prefix
     * @param {number} [limit] Max objects to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    listObjectsApiV1StorageListBucketGet_8Raw(requestParameters: ListObjectsApiV1StorageListBucketGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ObjectListResponse>>;

    /**
     * List objects in a bucket.  - **bucket**: Bucket name - **prefix**: Filter objects by prefix - **limit**: Maximum number of objects to return
     * List Objects
     */
    listObjectsApiV1StorageListBucketGet_8(requestParameters: ListObjectsApiV1StorageListBucketGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ObjectListResponse>;

    /**
     * Check storage service health.  Returns MinIO connection status and bucket count.
     * @summary Storage Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    storageHealthApiV1StorageHealthGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HealthResponse>>;

    /**
     * Check storage service health.  Returns MinIO connection status and bucket count.
     * Storage Health
     */
    storageHealthApiV1StorageHealthGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HealthResponse>;

    /**
     * Check storage service health.  Returns MinIO connection status and bucket count.
     * @summary Storage Health
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    storageHealthApiV1StorageHealthGet_9Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HealthResponse>>;

    /**
     * Check storage service health.  Returns MinIO connection status and bucket count.
     * Storage Health
     */
    storageHealthApiV1StorageHealthGet_9(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HealthResponse>;

    /**
     * Upload a file to storage.  - **file**: File to upload (multipart/form-data) - **bucket**: Target bucket (arabic-lessons-audio, arabic-lessons-images, user-recordings) - **path**: Optional path prefix  Requires authentication.
     * @summary Upload File
     * @param {string} bucket Target bucket name
     * @param {Blob} file 
     * @param {string} [path] Path prefix in bucket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    uploadFileApiV1StorageUploadPostRaw(requestParameters: UploadFileApiV1StorageUploadPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UploadResponse>>;

    /**
     * Upload a file to storage.  - **file**: File to upload (multipart/form-data) - **bucket**: Target bucket (arabic-lessons-audio, arabic-lessons-images, user-recordings) - **path**: Optional path prefix  Requires authentication.
     * Upload File
     */
    uploadFileApiV1StorageUploadPost(requestParameters: UploadFileApiV1StorageUploadPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UploadResponse>;

    /**
     * Upload a file to storage.  - **file**: File to upload (multipart/form-data) - **bucket**: Target bucket (arabic-lessons-audio, arabic-lessons-images, user-recordings) - **path**: Optional path prefix  Requires authentication.
     * @summary Upload File
     * @param {string} bucket Target bucket name
     * @param {Blob} file 
     * @param {string} [path] Path prefix in bucket
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    uploadFileApiV1StorageUploadPost_10Raw(requestParameters: UploadFileApiV1StorageUploadPost0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UploadResponse>>;

    /**
     * Upload a file to storage.  - **file**: File to upload (multipart/form-data) - **bucket**: Target bucket (arabic-lessons-audio, arabic-lessons-images, user-recordings) - **path**: Optional path prefix  Requires authentication.
     * Upload File
     */
    uploadFileApiV1StorageUploadPost_10(requestParameters: UploadFileApiV1StorageUploadPost0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UploadResponse>;

    /**
     * Upload user pronunciation recording.  - **file**: Audio file (webm, mp3, wav) - **lesson_id**: Lesson identifier  Requires authentication. Recording is saved to user\'s folder.
     * @summary Upload Recording
     * @param {string} lessonId Lesson ID
     * @param {Blob} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    uploadRecordingApiV1StorageArabicLessonsRecordingPostRaw(requestParameters: UploadRecordingApiV1StorageArabicLessonsRecordingPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Upload user pronunciation recording.  - **file**: Audio file (webm, mp3, wav) - **lesson_id**: Lesson identifier  Requires authentication. Recording is saved to user\'s folder.
     * Upload Recording
     */
    uploadRecordingApiV1StorageArabicLessonsRecordingPost(requestParameters: UploadRecordingApiV1StorageArabicLessonsRecordingPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Upload user pronunciation recording.  - **file**: Audio file (webm, mp3, wav) - **lesson_id**: Lesson identifier  Requires authentication. Recording is saved to user\'s folder.
     * @summary Upload Recording
     * @param {string} lessonId Lesson ID
     * @param {Blob} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageApiInterface
     */
    uploadRecordingApiV1StorageArabicLessonsRecordingPost_11Raw(requestParameters: UploadRecordingApiV1StorageArabicLessonsRecordingPost0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Upload user pronunciation recording.  - **file**: Audio file (webm, mp3, wav) - **lesson_id**: Lesson identifier  Requires authentication. Recording is saved to user\'s folder.
     * Upload Recording
     */
    uploadRecordingApiV1StorageArabicLessonsRecordingPost_11(requestParameters: UploadRecordingApiV1StorageArabicLessonsRecordingPost0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

}

/**
 * 
 */
export class StorageApi extends runtime.BaseAPI implements StorageApiInterface {

    /**
     * Delete an object from storage.  - **bucket**: Bucket name - **path**: Object path  For user-recordings, only the owner can delete.
     * Delete Object
     */
    async deleteObjectApiV1StorageBucketPathDeleteRaw(requestParameters: DeleteObjectApiV1StorageBucketPathDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteResponse>> {
        if (requestParameters['bucket'] == null) {
            throw new runtime.RequiredError(
                'bucket',
                'Required parameter "bucket" was null or undefined when calling deleteObjectApiV1StorageBucketPathDelete().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling deleteObjectApiV1StorageBucketPathDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/storage/{bucket}/{path}`;
        urlPath = urlPath.replace(`{${"bucket"}}`, encodeURIComponent(String(requestParameters['bucket'])));
        urlPath = urlPath.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeleteResponseFromJSON(jsonValue));
    }

    /**
     * Delete an object from storage.  - **bucket**: Bucket name - **path**: Object path  For user-recordings, only the owner can delete.
     * Delete Object
     */
    async deleteObjectApiV1StorageBucketPathDelete(requestParameters: DeleteObjectApiV1StorageBucketPathDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteResponse> {
        const response = await this.deleteObjectApiV1StorageBucketPathDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete an object from storage.  - **bucket**: Bucket name - **path**: Object path  For user-recordings, only the owner can delete.
     * Delete Object
     */
    async deleteObjectApiV1StorageBucketPathDelete_1Raw(requestParameters: DeleteObjectApiV1StorageBucketPathDelete0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DeleteResponse>> {
        if (requestParameters['bucket'] == null) {
            throw new runtime.RequiredError(
                'bucket',
                'Required parameter "bucket" was null or undefined when calling deleteObjectApiV1StorageBucketPathDelete_1().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling deleteObjectApiV1StorageBucketPathDelete_1().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/storage/{bucket}/{path}`;
        urlPath = urlPath.replace(`{${"bucket"}}`, encodeURIComponent(String(requestParameters['bucket'])));
        urlPath = urlPath.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DeleteResponseFromJSON(jsonValue));
    }

    /**
     * Delete an object from storage.  - **bucket**: Bucket name - **path**: Object path  For user-recordings, only the owner can delete.
     * Delete Object
     */
    async deleteObjectApiV1StorageBucketPathDelete_1(requestParameters: DeleteObjectApiV1StorageBucketPathDelete0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DeleteResponse> {
        const response = await this.deleteObjectApiV1StorageBucketPathDelete_1Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a file from storage.  Returns file content as binary stream.  - **bucket**: Source bucket - **path**: Object path in bucket
     * Download File
     */
    async downloadFileApiV1StorageDownloadBucketPathGetRaw(requestParameters: DownloadFileApiV1StorageDownloadBucketPathGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['bucket'] == null) {
            throw new runtime.RequiredError(
                'bucket',
                'Required parameter "bucket" was null or undefined when calling downloadFileApiV1StorageDownloadBucketPathGet().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling downloadFileApiV1StorageDownloadBucketPathGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/storage/download/{bucket}/{path}`;
        urlPath = urlPath.replace(`{${"bucket"}}`, encodeURIComponent(String(requestParameters['bucket'])));
        urlPath = urlPath.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Download a file from storage.  Returns file content as binary stream.  - **bucket**: Source bucket - **path**: Object path in bucket
     * Download File
     */
    async downloadFileApiV1StorageDownloadBucketPathGet(requestParameters: DownloadFileApiV1StorageDownloadBucketPathGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.downloadFileApiV1StorageDownloadBucketPathGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Download a file from storage.  Returns file content as binary stream.  - **bucket**: Source bucket - **path**: Object path in bucket
     * Download File
     */
    async downloadFileApiV1StorageDownloadBucketPathGet_2Raw(requestParameters: DownloadFileApiV1StorageDownloadBucketPathGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['bucket'] == null) {
            throw new runtime.RequiredError(
                'bucket',
                'Required parameter "bucket" was null or undefined when calling downloadFileApiV1StorageDownloadBucketPathGet_2().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling downloadFileApiV1StorageDownloadBucketPathGet_2().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/storage/download/{bucket}/{path}`;
        urlPath = urlPath.replace(`{${"bucket"}}`, encodeURIComponent(String(requestParameters['bucket'])));
        urlPath = urlPath.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Download a file from storage.  Returns file content as binary stream.  - **bucket**: Source bucket - **path**: Object path in bucket
     * Download File
     */
    async downloadFileApiV1StorageDownloadBucketPathGet_2(requestParameters: DownloadFileApiV1StorageDownloadBucketPathGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.downloadFileApiV1StorageDownloadBucketPathGet_2Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Arabic letter audio URL.  - **letter**: Letter name (alif, ba, ta, ...) - **form**: Form (isolated, initial, medial, final, name, sound, pronunciation) - **expires**: URL expiration in seconds
     * Get Arabic Audio
     */
    async getArabicAudioApiV1StorageArabicLessonsAudioLetterFormGetRaw(requestParameters: GetArabicAudioApiV1StorageArabicLessonsAudioLetterFormGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['letter'] == null) {
            throw new runtime.RequiredError(
                'letter',
                'Required parameter "letter" was null or undefined when calling getArabicAudioApiV1StorageArabicLessonsAudioLetterFormGet().'
            );
        }

        if (requestParameters['form'] == null) {
            throw new runtime.RequiredError(
                'form',
                'Required parameter "form" was null or undefined when calling getArabicAudioApiV1StorageArabicLessonsAudioLetterFormGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['expires'] != null) {
            queryParameters['expires'] = requestParameters['expires'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/storage/arabic-lessons/audio/{letter}/{form}`;
        urlPath = urlPath.replace(`{${"letter"}}`, encodeURIComponent(String(requestParameters['letter'])));
        urlPath = urlPath.replace(`{${"form"}}`, encodeURIComponent(String(requestParameters['form'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Get Arabic letter audio URL.  - **letter**: Letter name (alif, ba, ta, ...) - **form**: Form (isolated, initial, medial, final, name, sound, pronunciation) - **expires**: URL expiration in seconds
     * Get Arabic Audio
     */
    async getArabicAudioApiV1StorageArabicLessonsAudioLetterFormGet(requestParameters: GetArabicAudioApiV1StorageArabicLessonsAudioLetterFormGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getArabicAudioApiV1StorageArabicLessonsAudioLetterFormGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Arabic letter audio URL.  - **letter**: Letter name (alif, ba, ta, ...) - **form**: Form (isolated, initial, medial, final, name, sound, pronunciation) - **expires**: URL expiration in seconds
     * Get Arabic Audio
     */
    async getArabicAudioApiV1StorageArabicLessonsAudioLetterFormGet_3Raw(requestParameters: GetArabicAudioApiV1StorageArabicLessonsAudioLetterFormGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['letter'] == null) {
            throw new runtime.RequiredError(
                'letter',
                'Required parameter "letter" was null or undefined when calling getArabicAudioApiV1StorageArabicLessonsAudioLetterFormGet_3().'
            );
        }

        if (requestParameters['form'] == null) {
            throw new runtime.RequiredError(
                'form',
                'Required parameter "form" was null or undefined when calling getArabicAudioApiV1StorageArabicLessonsAudioLetterFormGet_3().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['expires'] != null) {
            queryParameters['expires'] = requestParameters['expires'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/storage/arabic-lessons/audio/{letter}/{form}`;
        urlPath = urlPath.replace(`{${"letter"}}`, encodeURIComponent(String(requestParameters['letter'])));
        urlPath = urlPath.replace(`{${"form"}}`, encodeURIComponent(String(requestParameters['form'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Get Arabic letter audio URL.  - **letter**: Letter name (alif, ba, ta, ...) - **form**: Form (isolated, initial, medial, final, name, sound, pronunciation) - **expires**: URL expiration in seconds
     * Get Arabic Audio
     */
    async getArabicAudioApiV1StorageArabicLessonsAudioLetterFormGet_3(requestParameters: GetArabicAudioApiV1StorageArabicLessonsAudioLetterFormGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getArabicAudioApiV1StorageArabicLessonsAudioLetterFormGet_3Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Arabic letter image URL.  - **letter**: Letter name - **category**: Category (standalone, in_word, diacritics) - **filename**: Image filename - **expires**: URL expiration in seconds
     * Get Arabic Image
     */
    async getArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGetRaw(requestParameters: GetArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['letter'] == null) {
            throw new runtime.RequiredError(
                'letter',
                'Required parameter "letter" was null or undefined when calling getArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGet().'
            );
        }

        if (requestParameters['category'] == null) {
            throw new runtime.RequiredError(
                'category',
                'Required parameter "category" was null or undefined when calling getArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGet().'
            );
        }

        if (requestParameters['filename'] == null) {
            throw new runtime.RequiredError(
                'filename',
                'Required parameter "filename" was null or undefined when calling getArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['expires'] != null) {
            queryParameters['expires'] = requestParameters['expires'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/storage/arabic-lessons/image/{letter}/{category}/{filename}`;
        urlPath = urlPath.replace(`{${"letter"}}`, encodeURIComponent(String(requestParameters['letter'])));
        urlPath = urlPath.replace(`{${"category"}}`, encodeURIComponent(String(requestParameters['category'])));
        urlPath = urlPath.replace(`{${"filename"}}`, encodeURIComponent(String(requestParameters['filename'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Get Arabic letter image URL.  - **letter**: Letter name - **category**: Category (standalone, in_word, diacritics) - **filename**: Image filename - **expires**: URL expiration in seconds
     * Get Arabic Image
     */
    async getArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGet(requestParameters: GetArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Arabic letter image URL.  - **letter**: Letter name - **category**: Category (standalone, in_word, diacritics) - **filename**: Image filename - **expires**: URL expiration in seconds
     * Get Arabic Image
     */
    async getArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGet_4Raw(requestParameters: GetArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['letter'] == null) {
            throw new runtime.RequiredError(
                'letter',
                'Required parameter "letter" was null or undefined when calling getArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGet_4().'
            );
        }

        if (requestParameters['category'] == null) {
            throw new runtime.RequiredError(
                'category',
                'Required parameter "category" was null or undefined when calling getArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGet_4().'
            );
        }

        if (requestParameters['filename'] == null) {
            throw new runtime.RequiredError(
                'filename',
                'Required parameter "filename" was null or undefined when calling getArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGet_4().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['expires'] != null) {
            queryParameters['expires'] = requestParameters['expires'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/storage/arabic-lessons/image/{letter}/{category}/{filename}`;
        urlPath = urlPath.replace(`{${"letter"}}`, encodeURIComponent(String(requestParameters['letter'])));
        urlPath = urlPath.replace(`{${"category"}}`, encodeURIComponent(String(requestParameters['category'])));
        urlPath = urlPath.replace(`{${"filename"}}`, encodeURIComponent(String(requestParameters['filename'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Get Arabic letter image URL.  - **letter**: Letter name - **category**: Category (standalone, in_word, diacritics) - **filename**: Image filename - **expires**: URL expiration in seconds
     * Get Arabic Image
     */
    async getArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGet_4(requestParameters: GetArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getArabicImageApiV1StorageArabicLessonsImageLetterCategoryFilenameGet_4Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get object metadata.  - **bucket**: Bucket name - **path**: Object path  Returns object size, content type, and other metadata.
     * Get Object Info
     */
    async getObjectInfoApiV1StorageInfoBucketPathGetRaw(requestParameters: GetObjectInfoApiV1StorageInfoBucketPathGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ObjectInfo>> {
        if (requestParameters['bucket'] == null) {
            throw new runtime.RequiredError(
                'bucket',
                'Required parameter "bucket" was null or undefined when calling getObjectInfoApiV1StorageInfoBucketPathGet().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling getObjectInfoApiV1StorageInfoBucketPathGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/storage/info/{bucket}/{path}`;
        urlPath = urlPath.replace(`{${"bucket"}}`, encodeURIComponent(String(requestParameters['bucket'])));
        urlPath = urlPath.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ObjectInfoFromJSON(jsonValue));
    }

    /**
     * Get object metadata.  - **bucket**: Bucket name - **path**: Object path  Returns object size, content type, and other metadata.
     * Get Object Info
     */
    async getObjectInfoApiV1StorageInfoBucketPathGet(requestParameters: GetObjectInfoApiV1StorageInfoBucketPathGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ObjectInfo> {
        const response = await this.getObjectInfoApiV1StorageInfoBucketPathGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get object metadata.  - **bucket**: Bucket name - **path**: Object path  Returns object size, content type, and other metadata.
     * Get Object Info
     */
    async getObjectInfoApiV1StorageInfoBucketPathGet_5Raw(requestParameters: GetObjectInfoApiV1StorageInfoBucketPathGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ObjectInfo>> {
        if (requestParameters['bucket'] == null) {
            throw new runtime.RequiredError(
                'bucket',
                'Required parameter "bucket" was null or undefined when calling getObjectInfoApiV1StorageInfoBucketPathGet_5().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling getObjectInfoApiV1StorageInfoBucketPathGet_5().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/storage/info/{bucket}/{path}`;
        urlPath = urlPath.replace(`{${"bucket"}}`, encodeURIComponent(String(requestParameters['bucket'])));
        urlPath = urlPath.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ObjectInfoFromJSON(jsonValue));
    }

    /**
     * Get object metadata.  - **bucket**: Bucket name - **path**: Object path  Returns object size, content type, and other metadata.
     * Get Object Info
     */
    async getObjectInfoApiV1StorageInfoBucketPathGet_5(requestParameters: GetObjectInfoApiV1StorageInfoBucketPathGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ObjectInfo> {
        const response = await this.getObjectInfoApiV1StorageInfoBucketPathGet_5Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get presigned URL for file access.  Returns a temporary URL valid for the specified duration.  - **bucket**: Bucket name - **path**: Object path - **expires**: URL expiration in seconds (60-86400)
     * Get Presigned Url
     */
    async getPresignedUrlApiV1StorageUrlBucketPathGetRaw(requestParameters: GetPresignedUrlApiV1StorageUrlBucketPathGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PresignedUrlResponse>> {
        if (requestParameters['bucket'] == null) {
            throw new runtime.RequiredError(
                'bucket',
                'Required parameter "bucket" was null or undefined when calling getPresignedUrlApiV1StorageUrlBucketPathGet().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling getPresignedUrlApiV1StorageUrlBucketPathGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['expires'] != null) {
            queryParameters['expires'] = requestParameters['expires'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/storage/url/{bucket}/{path}`;
        urlPath = urlPath.replace(`{${"bucket"}}`, encodeURIComponent(String(requestParameters['bucket'])));
        urlPath = urlPath.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PresignedUrlResponseFromJSON(jsonValue));
    }

    /**
     * Get presigned URL for file access.  Returns a temporary URL valid for the specified duration.  - **bucket**: Bucket name - **path**: Object path - **expires**: URL expiration in seconds (60-86400)
     * Get Presigned Url
     */
    async getPresignedUrlApiV1StorageUrlBucketPathGet(requestParameters: GetPresignedUrlApiV1StorageUrlBucketPathGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PresignedUrlResponse> {
        const response = await this.getPresignedUrlApiV1StorageUrlBucketPathGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get presigned URL for file access.  Returns a temporary URL valid for the specified duration.  - **bucket**: Bucket name - **path**: Object path - **expires**: URL expiration in seconds (60-86400)
     * Get Presigned Url
     */
    async getPresignedUrlApiV1StorageUrlBucketPathGet_6Raw(requestParameters: GetPresignedUrlApiV1StorageUrlBucketPathGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PresignedUrlResponse>> {
        if (requestParameters['bucket'] == null) {
            throw new runtime.RequiredError(
                'bucket',
                'Required parameter "bucket" was null or undefined when calling getPresignedUrlApiV1StorageUrlBucketPathGet_6().'
            );
        }

        if (requestParameters['path'] == null) {
            throw new runtime.RequiredError(
                'path',
                'Required parameter "path" was null or undefined when calling getPresignedUrlApiV1StorageUrlBucketPathGet_6().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['expires'] != null) {
            queryParameters['expires'] = requestParameters['expires'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/storage/url/{bucket}/{path}`;
        urlPath = urlPath.replace(`{${"bucket"}}`, encodeURIComponent(String(requestParameters['bucket'])));
        urlPath = urlPath.replace(`{${"path"}}`, encodeURIComponent(String(requestParameters['path'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PresignedUrlResponseFromJSON(jsonValue));
    }

    /**
     * Get presigned URL for file access.  Returns a temporary URL valid for the specified duration.  - **bucket**: Bucket name - **path**: Object path - **expires**: URL expiration in seconds (60-86400)
     * Get Presigned Url
     */
    async getPresignedUrlApiV1StorageUrlBucketPathGet_6(requestParameters: GetPresignedUrlApiV1StorageUrlBucketPathGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PresignedUrlResponse> {
        const response = await this.getPresignedUrlApiV1StorageUrlBucketPathGet_6Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get user\'s recordings.  - **lesson_id**: Optional lesson filter - **limit**: Maximum recordings to return  Returns list of recordings with presigned URLs.
     * Get User Recordings
     */
    async getUserRecordingsApiV1StorageArabicLessonsRecordingsGetRaw(requestParameters: GetUserRecordingsApiV1StorageArabicLessonsRecordingsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        if (requestParameters['lessonId'] != null) {
            queryParameters['lesson_id'] = requestParameters['lessonId'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/storage/arabic-lessons/recordings`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Get user\'s recordings.  - **lesson_id**: Optional lesson filter - **limit**: Maximum recordings to return  Returns list of recordings with presigned URLs.
     * Get User Recordings
     */
    async getUserRecordingsApiV1StorageArabicLessonsRecordingsGet(requestParameters: GetUserRecordingsApiV1StorageArabicLessonsRecordingsGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getUserRecordingsApiV1StorageArabicLessonsRecordingsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get user\'s recordings.  - **lesson_id**: Optional lesson filter - **limit**: Maximum recordings to return  Returns list of recordings with presigned URLs.
     * Get User Recordings
     */
    async getUserRecordingsApiV1StorageArabicLessonsRecordingsGet_7Raw(requestParameters: GetUserRecordingsApiV1StorageArabicLessonsRecordingsGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        if (requestParameters['lessonId'] != null) {
            queryParameters['lesson_id'] = requestParameters['lessonId'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/storage/arabic-lessons/recordings`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Get user\'s recordings.  - **lesson_id**: Optional lesson filter - **limit**: Maximum recordings to return  Returns list of recordings with presigned URLs.
     * Get User Recordings
     */
    async getUserRecordingsApiV1StorageArabicLessonsRecordingsGet_7(requestParameters: GetUserRecordingsApiV1StorageArabicLessonsRecordingsGet0Request = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getUserRecordingsApiV1StorageArabicLessonsRecordingsGet_7Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List objects in a bucket.  - **bucket**: Bucket name - **prefix**: Filter objects by prefix - **limit**: Maximum number of objects to return
     * List Objects
     */
    async listObjectsApiV1StorageListBucketGetRaw(requestParameters: ListObjectsApiV1StorageListBucketGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ObjectListResponse>> {
        if (requestParameters['bucket'] == null) {
            throw new runtime.RequiredError(
                'bucket',
                'Required parameter "bucket" was null or undefined when calling listObjectsApiV1StorageListBucketGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['prefix'] != null) {
            queryParameters['prefix'] = requestParameters['prefix'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/storage/list/{bucket}`;
        urlPath = urlPath.replace(`{${"bucket"}}`, encodeURIComponent(String(requestParameters['bucket'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ObjectListResponseFromJSON(jsonValue));
    }

    /**
     * List objects in a bucket.  - **bucket**: Bucket name - **prefix**: Filter objects by prefix - **limit**: Maximum number of objects to return
     * List Objects
     */
    async listObjectsApiV1StorageListBucketGet(requestParameters: ListObjectsApiV1StorageListBucketGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ObjectListResponse> {
        const response = await this.listObjectsApiV1StorageListBucketGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * List objects in a bucket.  - **bucket**: Bucket name - **prefix**: Filter objects by prefix - **limit**: Maximum number of objects to return
     * List Objects
     */
    async listObjectsApiV1StorageListBucketGet_8Raw(requestParameters: ListObjectsApiV1StorageListBucketGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ObjectListResponse>> {
        if (requestParameters['bucket'] == null) {
            throw new runtime.RequiredError(
                'bucket',
                'Required parameter "bucket" was null or undefined when calling listObjectsApiV1StorageListBucketGet_8().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['prefix'] != null) {
            queryParameters['prefix'] = requestParameters['prefix'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/storage/list/{bucket}`;
        urlPath = urlPath.replace(`{${"bucket"}}`, encodeURIComponent(String(requestParameters['bucket'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ObjectListResponseFromJSON(jsonValue));
    }

    /**
     * List objects in a bucket.  - **bucket**: Bucket name - **prefix**: Filter objects by prefix - **limit**: Maximum number of objects to return
     * List Objects
     */
    async listObjectsApiV1StorageListBucketGet_8(requestParameters: ListObjectsApiV1StorageListBucketGet0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ObjectListResponse> {
        const response = await this.listObjectsApiV1StorageListBucketGet_8Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Check storage service health.  Returns MinIO connection status and bucket count.
     * Storage Health
     */
    async storageHealthApiV1StorageHealthGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HealthResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/storage/health`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HealthResponseFromJSON(jsonValue));
    }

    /**
     * Check storage service health.  Returns MinIO connection status and bucket count.
     * Storage Health
     */
    async storageHealthApiV1StorageHealthGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HealthResponse> {
        const response = await this.storageHealthApiV1StorageHealthGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Check storage service health.  Returns MinIO connection status and bucket count.
     * Storage Health
     */
    async storageHealthApiV1StorageHealthGet_9Raw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HealthResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/storage/health`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HealthResponseFromJSON(jsonValue));
    }

    /**
     * Check storage service health.  Returns MinIO connection status and bucket count.
     * Storage Health
     */
    async storageHealthApiV1StorageHealthGet_9(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HealthResponse> {
        const response = await this.storageHealthApiV1StorageHealthGet_9Raw(initOverrides);
        return await response.value();
    }

    /**
     * Upload a file to storage.  - **file**: File to upload (multipart/form-data) - **bucket**: Target bucket (arabic-lessons-audio, arabic-lessons-images, user-recordings) - **path**: Optional path prefix  Requires authentication.
     * Upload File
     */
    async uploadFileApiV1StorageUploadPostRaw(requestParameters: UploadFileApiV1StorageUploadPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UploadResponse>> {
        if (requestParameters['bucket'] == null) {
            throw new runtime.RequiredError(
                'bucket',
                'Required parameter "bucket" was null or undefined when calling uploadFileApiV1StorageUploadPost().'
            );
        }

        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling uploadFileApiV1StorageUploadPost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['bucket'] != null) {
            queryParameters['bucket'] = requestParameters['bucket'];
        }

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }


        let urlPath = `/api/v1/storage/upload`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UploadResponseFromJSON(jsonValue));
    }

    /**
     * Upload a file to storage.  - **file**: File to upload (multipart/form-data) - **bucket**: Target bucket (arabic-lessons-audio, arabic-lessons-images, user-recordings) - **path**: Optional path prefix  Requires authentication.
     * Upload File
     */
    async uploadFileApiV1StorageUploadPost(requestParameters: UploadFileApiV1StorageUploadPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UploadResponse> {
        const response = await this.uploadFileApiV1StorageUploadPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload a file to storage.  - **file**: File to upload (multipart/form-data) - **bucket**: Target bucket (arabic-lessons-audio, arabic-lessons-images, user-recordings) - **path**: Optional path prefix  Requires authentication.
     * Upload File
     */
    async uploadFileApiV1StorageUploadPost_10Raw(requestParameters: UploadFileApiV1StorageUploadPost0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UploadResponse>> {
        if (requestParameters['bucket'] == null) {
            throw new runtime.RequiredError(
                'bucket',
                'Required parameter "bucket" was null or undefined when calling uploadFileApiV1StorageUploadPost_10().'
            );
        }

        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling uploadFileApiV1StorageUploadPost_10().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['bucket'] != null) {
            queryParameters['bucket'] = requestParameters['bucket'];
        }

        if (requestParameters['path'] != null) {
            queryParameters['path'] = requestParameters['path'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }


        let urlPath = `/api/v1/storage/upload`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UploadResponseFromJSON(jsonValue));
    }

    /**
     * Upload a file to storage.  - **file**: File to upload (multipart/form-data) - **bucket**: Target bucket (arabic-lessons-audio, arabic-lessons-images, user-recordings) - **path**: Optional path prefix  Requires authentication.
     * Upload File
     */
    async uploadFileApiV1StorageUploadPost_10(requestParameters: UploadFileApiV1StorageUploadPost0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UploadResponse> {
        const response = await this.uploadFileApiV1StorageUploadPost_10Raw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload user pronunciation recording.  - **file**: Audio file (webm, mp3, wav) - **lesson_id**: Lesson identifier  Requires authentication. Recording is saved to user\'s folder.
     * Upload Recording
     */
    async uploadRecordingApiV1StorageArabicLessonsRecordingPostRaw(requestParameters: UploadRecordingApiV1StorageArabicLessonsRecordingPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['lessonId'] == null) {
            throw new runtime.RequiredError(
                'lessonId',
                'Required parameter "lessonId" was null or undefined when calling uploadRecordingApiV1StorageArabicLessonsRecordingPost().'
            );
        }

        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling uploadRecordingApiV1StorageArabicLessonsRecordingPost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['lessonId'] != null) {
            queryParameters['lesson_id'] = requestParameters['lessonId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }


        let urlPath = `/api/v1/storage/arabic-lessons/recording`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Upload user pronunciation recording.  - **file**: Audio file (webm, mp3, wav) - **lesson_id**: Lesson identifier  Requires authentication. Recording is saved to user\'s folder.
     * Upload Recording
     */
    async uploadRecordingApiV1StorageArabicLessonsRecordingPost(requestParameters: UploadRecordingApiV1StorageArabicLessonsRecordingPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.uploadRecordingApiV1StorageArabicLessonsRecordingPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Upload user pronunciation recording.  - **file**: Audio file (webm, mp3, wav) - **lesson_id**: Lesson identifier  Requires authentication. Recording is saved to user\'s folder.
     * Upload Recording
     */
    async uploadRecordingApiV1StorageArabicLessonsRecordingPost_11Raw(requestParameters: UploadRecordingApiV1StorageArabicLessonsRecordingPost0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['lessonId'] == null) {
            throw new runtime.RequiredError(
                'lessonId',
                'Required parameter "lessonId" was null or undefined when calling uploadRecordingApiV1StorageArabicLessonsRecordingPost_11().'
            );
        }

        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling uploadRecordingApiV1StorageArabicLessonsRecordingPost_11().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['lessonId'] != null) {
            queryParameters['lesson_id'] = requestParameters['lessonId'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }


        let urlPath = `/api/v1/storage/arabic-lessons/recording`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Upload user pronunciation recording.  - **file**: Audio file (webm, mp3, wav) - **lesson_id**: Lesson identifier  Requires authentication. Recording is saved to user\'s folder.
     * Upload Recording
     */
    async uploadRecordingApiV1StorageArabicLessonsRecordingPost_11(requestParameters: UploadRecordingApiV1StorageArabicLessonsRecordingPost0Request, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.uploadRecordingApiV1StorageArabicLessonsRecordingPost_11Raw(requestParameters, initOverrides);
        return await response.value();
    }

}
