/* tslint:disable */
/* eslint-disable */
/**
 * Платформа Духовных Практик Gateway API
 *          ## Публичный REST API шлюз для платформы духовных практик                  ### Аутентификация         Все эндпоинты (кроме `/api/v1/auth/_*`) требуют JWT Bearer токен в заголовке Authorization.                  ### Основные возможности:         - **Цели (Goals)**: Управление духовными целями пользователей         - **Тасбих (Tasbih)**: Счетчик для духовных практик         - **Азкары (Azkar)**: Ежедневные поминания         - **Quran API**: Работа с Кораном, переводами и аудио         - **Библиотека**: Управление пользовательским контентом         - **Отчеты**: Генерация отчетов о духовной активности                  ### Статус коды:         - `200` - Успешный запрос         - `201` - Ресурс создан         - `400` - Неверный формат запроса         - `401` - Требуется авторизация         - `403` - Доступ запрещен         - `404` - Ресурс не найден         - `422` - Ошибка валидации данных         - `500` - Внутренняя ошибка сервера         - `503` - Сервис недоступен                  ### Health Checks:         - `GET /health` - Базовый health check         - `GET /health/ready` - Readiness probe (Kubernetes)         - `GET /health/live` - Liveness probe (Kubernetes)         - `GET /metrics` - Prometheus метрики         
 *
 * The version of the OpenAPI document: 1.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  HTTPValidationError,
} from '../models/index';
import {
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
} from '../models/index';

export interface CreateEntryApiV1KnowledgeEntriesPostRequest {
    requestBody: { [key: string]: any; };
}

export interface CreateExampleApiV1KnowledgeExamplesPostRequest {
    requestBody: { [key: string]: any; };
}

export interface CreateMediaApiV1KnowledgeMediaPostRequest {
    requestBody: { [key: string]: any; };
}

export interface CreateSourceApiV1KnowledgeSourcesPostRequest {
    requestBody: { [key: string]: any; };
}

export interface CreateTranslationApiV1KnowledgeTranslationsPostRequest {
    requestBody: { [key: string]: any; };
}

export interface DeleteEntryApiV1KnowledgeEntriesEntryIdDeleteRequest {
    entryId: string;
}

export interface GetContextKnowledgeApiV1KnowledgeContextContextTypeContextIdGetRequest {
    contextType: string;
    contextId: string;
}

export interface GetEntriesApiV1KnowledgeEntriesGetRequest {
    entryType?: string | null;
    category?: string | null;
    difficultyLevel?: string | null;
    isActive?: boolean;
    limit?: number;
    offset?: number;
}

export interface GetEntriesByCategoryApiV1KnowledgeEntriesCategoryCategoryGetRequest {
    category: string;
    limit?: number;
}

export interface GetEntriesByDifficultyApiV1KnowledgeEntriesDifficultyDifficultyLevelGetRequest {
    difficultyLevel: string;
    limit?: number;
}

export interface GetEntriesByImportanceApiV1KnowledgeEntriesImportanceMinImportanceGetRequest {
    minImportance: number;
    limit?: number;
}

export interface GetEntriesByTypeApiV1KnowledgeEntriesTypeEntryTypeGetRequest {
    entryType: string;
    limit?: number;
}

export interface GetEntryApiV1KnowledgeEntriesEntryIdGetRequest {
    entryId: string;
}

export interface GetEntryByArabicTermApiV1KnowledgeEntriesByTermTermArabicGetRequest {
    termArabic: string;
}

export interface GetEntryByTransliterationApiV1KnowledgeEntriesByTransliterationTransliterationGetRequest {
    transliteration: string;
}

export interface GetEntryFullInfoApiV1KnowledgeEntriesEntryIdFullGetRequest {
    entryId: string;
}

export interface GetExamplesByEntryApiV1KnowledgeEntriesEntryIdExamplesGetRequest {
    entryId: string;
}

export interface GetMediaByEntryApiV1KnowledgeEntriesEntryIdMediaGetRequest {
    entryId: string;
}

export interface GetMediaByTypeApiV1KnowledgeEntriesEntryIdMediaMediaTypeGetRequest {
    entryId: string;
    mediaType: string;
}

export interface GetRandomEntryApiV1KnowledgeEntriesRandomGetRequest {
    category?: string | null;
    entryType?: string | null;
}

export interface GetSourcesByEntryApiV1KnowledgeEntriesEntryIdSourcesGetRequest {
    entryId: string;
}

export interface GetSourcesByTypeApiV1KnowledgeEntriesEntryIdSourcesSourceTypeGetRequest {
    entryId: string;
    sourceType: string;
}

export interface GetTranslationByLanguageApiV1KnowledgeEntriesEntryIdTranslationsLanguageGetRequest {
    entryId: string;
    language: string;
}

export interface GetTranslationsByEntryApiV1KnowledgeEntriesEntryIdTranslationsGetRequest {
    entryId: string;
}

export interface SearchEntriesApiV1KnowledgeSearchGetRequest {
    q: string;
    category?: string | null;
    entryType?: string | null;
    limit?: number;
}

export interface SearchEntriesPostApiV1KnowledgeSearchPostRequest {
    requestBody: { [key: string]: any; };
}

export interface SemanticSearchApiV1KnowledgeSearchSemanticPostRequest {
    query: string;
    category?: string | null;
    limit?: number;
}

export interface SuggestTermsApiV1KnowledgeSuggestGetRequest {
    q: string;
    limit?: number;
}

export interface UpdateEntryApiV1KnowledgeEntriesEntryIdPutRequest {
    entryId: string;
    requestBody: { [key: string]: any; };
}

export interface UpdateExampleApiV1KnowledgeExamplesExampleIdPutRequest {
    exampleId: string;
    requestBody: { [key: string]: any; };
}

export interface UpdateMediaApiV1KnowledgeMediaMediaIdPutRequest {
    mediaId: string;
    requestBody: { [key: string]: any; };
}

export interface UpdateSourceApiV1KnowledgeSourcesSourceIdPutRequest {
    sourceId: string;
    requestBody: { [key: string]: any; };
}

export interface UpdateTranslationApiV1KnowledgeTranslationsTranslationIdPutRequest {
    translationId: string;
    requestBody: { [key: string]: any; };
}

/**
 * KnowledgeApi - interface
 * 
 * @export
 * @interface KnowledgeApiInterface
 */
export interface KnowledgeApiInterface {
    /**
     * Создать новую запись (только для админов)
     * @summary Create Entry
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    createEntryApiV1KnowledgeEntriesPostRaw(requestParameters: CreateEntryApiV1KnowledgeEntriesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Создать новую запись (только для админов)
     * Create Entry
     */
    createEntryApiV1KnowledgeEntriesPost(requestParameters: CreateEntryApiV1KnowledgeEntriesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Создать новый пример (только для админов)
     * @summary Create Example
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    createExampleApiV1KnowledgeExamplesPostRaw(requestParameters: CreateExampleApiV1KnowledgeExamplesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Создать новый пример (только для админов)
     * Create Example
     */
    createExampleApiV1KnowledgeExamplesPost(requestParameters: CreateExampleApiV1KnowledgeExamplesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Создать новую медиа запись (только для админов)
     * @summary Create Media
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    createMediaApiV1KnowledgeMediaPostRaw(requestParameters: CreateMediaApiV1KnowledgeMediaPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Создать новую медиа запись (только для админов)
     * Create Media
     */
    createMediaApiV1KnowledgeMediaPost(requestParameters: CreateMediaApiV1KnowledgeMediaPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Создать новый источник (только для админов)
     * @summary Create Source
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    createSourceApiV1KnowledgeSourcesPostRaw(requestParameters: CreateSourceApiV1KnowledgeSourcesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Создать новый источник (только для админов)
     * Create Source
     */
    createSourceApiV1KnowledgeSourcesPost(requestParameters: CreateSourceApiV1KnowledgeSourcesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Создать новый перевод (только для админов)
     * @summary Create Translation
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    createTranslationApiV1KnowledgeTranslationsPostRaw(requestParameters: CreateTranslationApiV1KnowledgeTranslationsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Создать новый перевод (только для админов)
     * Create Translation
     */
    createTranslationApiV1KnowledgeTranslationsPost(requestParameters: CreateTranslationApiV1KnowledgeTranslationsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Удалить запись (только для админов)
     * @summary Delete Entry
     * @param {string} entryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    deleteEntryApiV1KnowledgeEntriesEntryIdDeleteRaw(requestParameters: DeleteEntryApiV1KnowledgeEntriesEntryIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Удалить запись (только для админов)
     * Delete Entry
     */
    deleteEntryApiV1KnowledgeEntriesEntryIdDelete(requestParameters: DeleteEntryApiV1KnowledgeEntriesEntryIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить статистику по категориям
     * @summary Get Category Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getCategoryStatsApiV1KnowledgeStatsCategoriesGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить статистику по категориям
     * Get Category Stats
     */
    getCategoryStatsApiV1KnowledgeStatsCategoriesGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить знания для контекста
     * @summary Get Context Knowledge
     * @param {string} contextType 
     * @param {string} contextId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getContextKnowledgeApiV1KnowledgeContextContextTypeContextIdGetRaw(requestParameters: GetContextKnowledgeApiV1KnowledgeContextContextTypeContextIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить знания для контекста
     * Get Context Knowledge
     */
    getContextKnowledgeApiV1KnowledgeContextContextTypeContextIdGet(requestParameters: GetContextKnowledgeApiV1KnowledgeContextContextTypeContextIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить статистику по сложности
     * @summary Get Difficulty Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getDifficultyStatsApiV1KnowledgeStatsDifficultyGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить статистику по сложности
     * Get Difficulty Stats
     */
    getDifficultyStatsApiV1KnowledgeStatsDifficultyGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить список записей базы знаний
     * @summary Get Entries
     * @param {string} [entryType] 
     * @param {string} [category] 
     * @param {string} [difficultyLevel] 
     * @param {boolean} [isActive] 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getEntriesApiV1KnowledgeEntriesGetRaw(requestParameters: GetEntriesApiV1KnowledgeEntriesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить список записей базы знаний
     * Get Entries
     */
    getEntriesApiV1KnowledgeEntriesGet(requestParameters: GetEntriesApiV1KnowledgeEntriesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить записи по категории
     * @summary Get Entries By Category
     * @param {string} category 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getEntriesByCategoryApiV1KnowledgeEntriesCategoryCategoryGetRaw(requestParameters: GetEntriesByCategoryApiV1KnowledgeEntriesCategoryCategoryGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить записи по категории
     * Get Entries By Category
     */
    getEntriesByCategoryApiV1KnowledgeEntriesCategoryCategoryGet(requestParameters: GetEntriesByCategoryApiV1KnowledgeEntriesCategoryCategoryGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить записи по уровню сложности
     * @summary Get Entries By Difficulty
     * @param {string} difficultyLevel 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getEntriesByDifficultyApiV1KnowledgeEntriesDifficultyDifficultyLevelGetRaw(requestParameters: GetEntriesByDifficultyApiV1KnowledgeEntriesDifficultyDifficultyLevelGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить записи по уровню сложности
     * Get Entries By Difficulty
     */
    getEntriesByDifficultyApiV1KnowledgeEntriesDifficultyDifficultyLevelGet(requestParameters: GetEntriesByDifficultyApiV1KnowledgeEntriesDifficultyDifficultyLevelGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить записи по важности
     * @summary Get Entries By Importance
     * @param {number} minImportance 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getEntriesByImportanceApiV1KnowledgeEntriesImportanceMinImportanceGetRaw(requestParameters: GetEntriesByImportanceApiV1KnowledgeEntriesImportanceMinImportanceGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить записи по важности
     * Get Entries By Importance
     */
    getEntriesByImportanceApiV1KnowledgeEntriesImportanceMinImportanceGet(requestParameters: GetEntriesByImportanceApiV1KnowledgeEntriesImportanceMinImportanceGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить записи по типу
     * @summary Get Entries By Type
     * @param {string} entryType 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getEntriesByTypeApiV1KnowledgeEntriesTypeEntryTypeGetRaw(requestParameters: GetEntriesByTypeApiV1KnowledgeEntriesTypeEntryTypeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить записи по типу
     * Get Entries By Type
     */
    getEntriesByTypeApiV1KnowledgeEntriesTypeEntryTypeGet(requestParameters: GetEntriesByTypeApiV1KnowledgeEntriesTypeEntryTypeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить запись по ID
     * @summary Get Entry
     * @param {string} entryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getEntryApiV1KnowledgeEntriesEntryIdGetRaw(requestParameters: GetEntryApiV1KnowledgeEntriesEntryIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить запись по ID
     * Get Entry
     */
    getEntryApiV1KnowledgeEntriesEntryIdGet(requestParameters: GetEntryApiV1KnowledgeEntriesEntryIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить запись по арабскому термину
     * @summary Get Entry By Arabic Term
     * @param {string} termArabic 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getEntryByArabicTermApiV1KnowledgeEntriesByTermTermArabicGetRaw(requestParameters: GetEntryByArabicTermApiV1KnowledgeEntriesByTermTermArabicGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить запись по арабскому термину
     * Get Entry By Arabic Term
     */
    getEntryByArabicTermApiV1KnowledgeEntriesByTermTermArabicGet(requestParameters: GetEntryByArabicTermApiV1KnowledgeEntriesByTermTermArabicGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить запись по транслитерации
     * @summary Get Entry By Transliteration
     * @param {string} transliteration 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getEntryByTransliterationApiV1KnowledgeEntriesByTransliterationTransliterationGetRaw(requestParameters: GetEntryByTransliterationApiV1KnowledgeEntriesByTransliterationTransliterationGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить запись по транслитерации
     * Get Entry By Transliteration
     */
    getEntryByTransliterationApiV1KnowledgeEntriesByTransliterationTransliterationGet(requestParameters: GetEntryByTransliterationApiV1KnowledgeEntriesByTransliterationTransliterationGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить полную информацию о записи со всеми связанными данными
     * @summary Get Entry Full Info
     * @param {string} entryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getEntryFullInfoApiV1KnowledgeEntriesEntryIdFullGetRaw(requestParameters: GetEntryFullInfoApiV1KnowledgeEntriesEntryIdFullGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить полную информацию о записи со всеми связанными данными
     * Get Entry Full Info
     */
    getEntryFullInfoApiV1KnowledgeEntriesEntryIdFullGet(requestParameters: GetEntryFullInfoApiV1KnowledgeEntriesEntryIdFullGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить примеры для записи
     * @summary Get Examples By Entry
     * @param {string} entryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getExamplesByEntryApiV1KnowledgeEntriesEntryIdExamplesGetRaw(requestParameters: GetExamplesByEntryApiV1KnowledgeEntriesEntryIdExamplesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить примеры для записи
     * Get Examples By Entry
     */
    getExamplesByEntryApiV1KnowledgeEntriesEntryIdExamplesGet(requestParameters: GetExamplesByEntryApiV1KnowledgeEntriesEntryIdExamplesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить медиа файлы для записи
     * @summary Get Media By Entry
     * @param {string} entryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getMediaByEntryApiV1KnowledgeEntriesEntryIdMediaGetRaw(requestParameters: GetMediaByEntryApiV1KnowledgeEntriesEntryIdMediaGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить медиа файлы для записи
     * Get Media By Entry
     */
    getMediaByEntryApiV1KnowledgeEntriesEntryIdMediaGet(requestParameters: GetMediaByEntryApiV1KnowledgeEntriesEntryIdMediaGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить медиа файлы определенного типа
     * @summary Get Media By Type
     * @param {string} entryId 
     * @param {string} mediaType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getMediaByTypeApiV1KnowledgeEntriesEntryIdMediaMediaTypeGetRaw(requestParameters: GetMediaByTypeApiV1KnowledgeEntriesEntryIdMediaMediaTypeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить медиа файлы определенного типа
     * Get Media By Type
     */
    getMediaByTypeApiV1KnowledgeEntriesEntryIdMediaMediaTypeGet(requestParameters: GetMediaByTypeApiV1KnowledgeEntriesEntryIdMediaMediaTypeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить случайную запись
     * @summary Get Random Entry
     * @param {string} [category] 
     * @param {string} [entryType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getRandomEntryApiV1KnowledgeEntriesRandomGetRaw(requestParameters: GetRandomEntryApiV1KnowledgeEntriesRandomGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить случайную запись
     * Get Random Entry
     */
    getRandomEntryApiV1KnowledgeEntriesRandomGet(requestParameters: GetRandomEntryApiV1KnowledgeEntriesRandomGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить источники для записи
     * @summary Get Sources By Entry
     * @param {string} entryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getSourcesByEntryApiV1KnowledgeEntriesEntryIdSourcesGetRaw(requestParameters: GetSourcesByEntryApiV1KnowledgeEntriesEntryIdSourcesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить источники для записи
     * Get Sources By Entry
     */
    getSourcesByEntryApiV1KnowledgeEntriesEntryIdSourcesGet(requestParameters: GetSourcesByEntryApiV1KnowledgeEntriesEntryIdSourcesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить источники определенного типа
     * @summary Get Sources By Type
     * @param {string} entryId 
     * @param {string} sourceType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getSourcesByTypeApiV1KnowledgeEntriesEntryIdSourcesSourceTypeGetRaw(requestParameters: GetSourcesByTypeApiV1KnowledgeEntriesEntryIdSourcesSourceTypeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить источники определенного типа
     * Get Sources By Type
     */
    getSourcesByTypeApiV1KnowledgeEntriesEntryIdSourcesSourceTypeGet(requestParameters: GetSourcesByTypeApiV1KnowledgeEntriesEntryIdSourcesSourceTypeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить общее количество активных записей
     * @summary Get Total Count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getTotalCountApiV1KnowledgeStatsTotalGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить общее количество активных записей
     * Get Total Count
     */
    getTotalCountApiV1KnowledgeStatsTotalGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить перевод на конкретном языке
     * @summary Get Translation By Language
     * @param {string} entryId 
     * @param {string} language 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getTranslationByLanguageApiV1KnowledgeEntriesEntryIdTranslationsLanguageGetRaw(requestParameters: GetTranslationByLanguageApiV1KnowledgeEntriesEntryIdTranslationsLanguageGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить перевод на конкретном языке
     * Get Translation By Language
     */
    getTranslationByLanguageApiV1KnowledgeEntriesEntryIdTranslationsLanguageGet(requestParameters: GetTranslationByLanguageApiV1KnowledgeEntriesEntryIdTranslationsLanguageGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить переводы для записи
     * @summary Get Translations By Entry
     * @param {string} entryId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getTranslationsByEntryApiV1KnowledgeEntriesEntryIdTranslationsGetRaw(requestParameters: GetTranslationsByEntryApiV1KnowledgeEntriesEntryIdTranslationsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить переводы для записи
     * Get Translations By Entry
     */
    getTranslationsByEntryApiV1KnowledgeEntriesEntryIdTranslationsGet(requestParameters: GetTranslationsByEntryApiV1KnowledgeEntriesEntryIdTranslationsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Получить статистику по типам
     * @summary Get Type Stats
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    getTypeStatsApiV1KnowledgeStatsTypesGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Получить статистику по типам
     * Get Type Stats
     */
    getTypeStatsApiV1KnowledgeStatsTypesGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Проверка здоровья API
     * @summary Health Check
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    healthCheckApiV1KnowledgeHealthGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Проверка здоровья API
     * Health Check
     */
    healthCheckApiV1KnowledgeHealthGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Поиск записей по тексту
     * @summary Search Entries
     * @param {string} q Поисковый запрос
     * @param {string} [category] 
     * @param {string} [entryType] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    searchEntriesApiV1KnowledgeSearchGetRaw(requestParameters: SearchEntriesApiV1KnowledgeSearchGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Поиск записей по тексту
     * Search Entries
     */
    searchEntriesApiV1KnowledgeSearchGet(requestParameters: SearchEntriesApiV1KnowledgeSearchGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Поиск записей по тексту (POST для поддержки кириллицы)
     * @summary Search Entries Post
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    searchEntriesPostApiV1KnowledgeSearchPostRaw(requestParameters: SearchEntriesPostApiV1KnowledgeSearchPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Поиск записей по тексту (POST для поддержки кириллицы)
     * Search Entries Post
     */
    searchEntriesPostApiV1KnowledgeSearchPost(requestParameters: SearchEntriesPostApiV1KnowledgeSearchPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Семантический поиск (заглушка для будущей реализации)
     * @summary Semantic Search
     * @param {string} query 
     * @param {string} [category] 
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    semanticSearchApiV1KnowledgeSearchSemanticPostRaw(requestParameters: SemanticSearchApiV1KnowledgeSearchSemanticPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Семантический поиск (заглушка для будущей реализации)
     * Semantic Search
     */
    semanticSearchApiV1KnowledgeSearchSemanticPost(requestParameters: SemanticSearchApiV1KnowledgeSearchSemanticPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Автоподсказки для текста на основе поиска терминов
     * @summary Suggest Terms
     * @param {string} q Текст для анализа
     * @param {number} [limit] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    suggestTermsApiV1KnowledgeSuggestGetRaw(requestParameters: SuggestTermsApiV1KnowledgeSuggestGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Автоподсказки для текста на основе поиска терминов
     * Suggest Terms
     */
    suggestTermsApiV1KnowledgeSuggestGet(requestParameters: SuggestTermsApiV1KnowledgeSuggestGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Обновить запись (только для админов)
     * @summary Update Entry
     * @param {string} entryId 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    updateEntryApiV1KnowledgeEntriesEntryIdPutRaw(requestParameters: UpdateEntryApiV1KnowledgeEntriesEntryIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Обновить запись (только для админов)
     * Update Entry
     */
    updateEntryApiV1KnowledgeEntriesEntryIdPut(requestParameters: UpdateEntryApiV1KnowledgeEntriesEntryIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Обновить пример (только для админов)
     * @summary Update Example
     * @param {string} exampleId 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    updateExampleApiV1KnowledgeExamplesExampleIdPutRaw(requestParameters: UpdateExampleApiV1KnowledgeExamplesExampleIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Обновить пример (только для админов)
     * Update Example
     */
    updateExampleApiV1KnowledgeExamplesExampleIdPut(requestParameters: UpdateExampleApiV1KnowledgeExamplesExampleIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Обновить медиа запись (только для админов)
     * @summary Update Media
     * @param {string} mediaId 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    updateMediaApiV1KnowledgeMediaMediaIdPutRaw(requestParameters: UpdateMediaApiV1KnowledgeMediaMediaIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Обновить медиа запись (только для админов)
     * Update Media
     */
    updateMediaApiV1KnowledgeMediaMediaIdPut(requestParameters: UpdateMediaApiV1KnowledgeMediaMediaIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Обновить источник (только для админов)
     * @summary Update Source
     * @param {string} sourceId 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    updateSourceApiV1KnowledgeSourcesSourceIdPutRaw(requestParameters: UpdateSourceApiV1KnowledgeSourcesSourceIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Обновить источник (только для админов)
     * Update Source
     */
    updateSourceApiV1KnowledgeSourcesSourceIdPut(requestParameters: UpdateSourceApiV1KnowledgeSourcesSourceIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Обновить перевод (только для админов)
     * @summary Update Translation
     * @param {string} translationId 
     * @param {{ [key: string]: any; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KnowledgeApiInterface
     */
    updateTranslationApiV1KnowledgeTranslationsTranslationIdPutRaw(requestParameters: UpdateTranslationApiV1KnowledgeTranslationsTranslationIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Обновить перевод (только для админов)
     * Update Translation
     */
    updateTranslationApiV1KnowledgeTranslationsTranslationIdPut(requestParameters: UpdateTranslationApiV1KnowledgeTranslationsTranslationIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

}

/**
 * 
 */
export class KnowledgeApi extends runtime.BaseAPI implements KnowledgeApiInterface {

    /**
     * Создать новую запись (только для админов)
     * Create Entry
     */
    async createEntryApiV1KnowledgeEntriesPostRaw(requestParameters: CreateEntryApiV1KnowledgeEntriesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling createEntryApiV1KnowledgeEntriesPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/entries`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Создать новую запись (только для админов)
     * Create Entry
     */
    async createEntryApiV1KnowledgeEntriesPost(requestParameters: CreateEntryApiV1KnowledgeEntriesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.createEntryApiV1KnowledgeEntriesPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Создать новый пример (только для админов)
     * Create Example
     */
    async createExampleApiV1KnowledgeExamplesPostRaw(requestParameters: CreateExampleApiV1KnowledgeExamplesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling createExampleApiV1KnowledgeExamplesPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/examples`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Создать новый пример (только для админов)
     * Create Example
     */
    async createExampleApiV1KnowledgeExamplesPost(requestParameters: CreateExampleApiV1KnowledgeExamplesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.createExampleApiV1KnowledgeExamplesPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Создать новую медиа запись (только для админов)
     * Create Media
     */
    async createMediaApiV1KnowledgeMediaPostRaw(requestParameters: CreateMediaApiV1KnowledgeMediaPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling createMediaApiV1KnowledgeMediaPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/media`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Создать новую медиа запись (только для админов)
     * Create Media
     */
    async createMediaApiV1KnowledgeMediaPost(requestParameters: CreateMediaApiV1KnowledgeMediaPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.createMediaApiV1KnowledgeMediaPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Создать новый источник (только для админов)
     * Create Source
     */
    async createSourceApiV1KnowledgeSourcesPostRaw(requestParameters: CreateSourceApiV1KnowledgeSourcesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling createSourceApiV1KnowledgeSourcesPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/sources`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Создать новый источник (только для админов)
     * Create Source
     */
    async createSourceApiV1KnowledgeSourcesPost(requestParameters: CreateSourceApiV1KnowledgeSourcesPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.createSourceApiV1KnowledgeSourcesPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Создать новый перевод (только для админов)
     * Create Translation
     */
    async createTranslationApiV1KnowledgeTranslationsPostRaw(requestParameters: CreateTranslationApiV1KnowledgeTranslationsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling createTranslationApiV1KnowledgeTranslationsPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/translations`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Создать новый перевод (только для админов)
     * Create Translation
     */
    async createTranslationApiV1KnowledgeTranslationsPost(requestParameters: CreateTranslationApiV1KnowledgeTranslationsPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.createTranslationApiV1KnowledgeTranslationsPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Удалить запись (только для админов)
     * Delete Entry
     */
    async deleteEntryApiV1KnowledgeEntriesEntryIdDeleteRaw(requestParameters: DeleteEntryApiV1KnowledgeEntriesEntryIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['entryId'] == null) {
            throw new runtime.RequiredError(
                'entryId',
                'Required parameter "entryId" was null or undefined when calling deleteEntryApiV1KnowledgeEntriesEntryIdDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/entries/{entry_id}`;
        urlPath = urlPath.replace(`{${"entry_id"}}`, encodeURIComponent(String(requestParameters['entryId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Удалить запись (только для админов)
     * Delete Entry
     */
    async deleteEntryApiV1KnowledgeEntriesEntryIdDelete(requestParameters: DeleteEntryApiV1KnowledgeEntriesEntryIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deleteEntryApiV1KnowledgeEntriesEntryIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить статистику по категориям
     * Get Category Stats
     */
    async getCategoryStatsApiV1KnowledgeStatsCategoriesGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/stats/categories`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить статистику по категориям
     * Get Category Stats
     */
    async getCategoryStatsApiV1KnowledgeStatsCategoriesGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getCategoryStatsApiV1KnowledgeStatsCategoriesGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Получить знания для контекста
     * Get Context Knowledge
     */
    async getContextKnowledgeApiV1KnowledgeContextContextTypeContextIdGetRaw(requestParameters: GetContextKnowledgeApiV1KnowledgeContextContextTypeContextIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['contextType'] == null) {
            throw new runtime.RequiredError(
                'contextType',
                'Required parameter "contextType" was null or undefined when calling getContextKnowledgeApiV1KnowledgeContextContextTypeContextIdGet().'
            );
        }

        if (requestParameters['contextId'] == null) {
            throw new runtime.RequiredError(
                'contextId',
                'Required parameter "contextId" was null or undefined when calling getContextKnowledgeApiV1KnowledgeContextContextTypeContextIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/context/{context_type}/{context_id}`;
        urlPath = urlPath.replace(`{${"context_type"}}`, encodeURIComponent(String(requestParameters['contextType'])));
        urlPath = urlPath.replace(`{${"context_id"}}`, encodeURIComponent(String(requestParameters['contextId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить знания для контекста
     * Get Context Knowledge
     */
    async getContextKnowledgeApiV1KnowledgeContextContextTypeContextIdGet(requestParameters: GetContextKnowledgeApiV1KnowledgeContextContextTypeContextIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getContextKnowledgeApiV1KnowledgeContextContextTypeContextIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить статистику по сложности
     * Get Difficulty Stats
     */
    async getDifficultyStatsApiV1KnowledgeStatsDifficultyGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/stats/difficulty`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить статистику по сложности
     * Get Difficulty Stats
     */
    async getDifficultyStatsApiV1KnowledgeStatsDifficultyGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getDifficultyStatsApiV1KnowledgeStatsDifficultyGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Получить список записей базы знаний
     * Get Entries
     */
    async getEntriesApiV1KnowledgeEntriesGetRaw(requestParameters: GetEntriesApiV1KnowledgeEntriesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        if (requestParameters['entryType'] != null) {
            queryParameters['entry_type'] = requestParameters['entryType'];
        }

        if (requestParameters['category'] != null) {
            queryParameters['category'] = requestParameters['category'];
        }

        if (requestParameters['difficultyLevel'] != null) {
            queryParameters['difficulty_level'] = requestParameters['difficultyLevel'];
        }

        if (requestParameters['isActive'] != null) {
            queryParameters['is_active'] = requestParameters['isActive'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/entries`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить список записей базы знаний
     * Get Entries
     */
    async getEntriesApiV1KnowledgeEntriesGet(requestParameters: GetEntriesApiV1KnowledgeEntriesGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getEntriesApiV1KnowledgeEntriesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить записи по категории
     * Get Entries By Category
     */
    async getEntriesByCategoryApiV1KnowledgeEntriesCategoryCategoryGetRaw(requestParameters: GetEntriesByCategoryApiV1KnowledgeEntriesCategoryCategoryGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['category'] == null) {
            throw new runtime.RequiredError(
                'category',
                'Required parameter "category" was null or undefined when calling getEntriesByCategoryApiV1KnowledgeEntriesCategoryCategoryGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/entries/category/{category}`;
        urlPath = urlPath.replace(`{${"category"}}`, encodeURIComponent(String(requestParameters['category'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить записи по категории
     * Get Entries By Category
     */
    async getEntriesByCategoryApiV1KnowledgeEntriesCategoryCategoryGet(requestParameters: GetEntriesByCategoryApiV1KnowledgeEntriesCategoryCategoryGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getEntriesByCategoryApiV1KnowledgeEntriesCategoryCategoryGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить записи по уровню сложности
     * Get Entries By Difficulty
     */
    async getEntriesByDifficultyApiV1KnowledgeEntriesDifficultyDifficultyLevelGetRaw(requestParameters: GetEntriesByDifficultyApiV1KnowledgeEntriesDifficultyDifficultyLevelGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['difficultyLevel'] == null) {
            throw new runtime.RequiredError(
                'difficultyLevel',
                'Required parameter "difficultyLevel" was null or undefined when calling getEntriesByDifficultyApiV1KnowledgeEntriesDifficultyDifficultyLevelGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/entries/difficulty/{difficulty_level}`;
        urlPath = urlPath.replace(`{${"difficulty_level"}}`, encodeURIComponent(String(requestParameters['difficultyLevel'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить записи по уровню сложности
     * Get Entries By Difficulty
     */
    async getEntriesByDifficultyApiV1KnowledgeEntriesDifficultyDifficultyLevelGet(requestParameters: GetEntriesByDifficultyApiV1KnowledgeEntriesDifficultyDifficultyLevelGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getEntriesByDifficultyApiV1KnowledgeEntriesDifficultyDifficultyLevelGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить записи по важности
     * Get Entries By Importance
     */
    async getEntriesByImportanceApiV1KnowledgeEntriesImportanceMinImportanceGetRaw(requestParameters: GetEntriesByImportanceApiV1KnowledgeEntriesImportanceMinImportanceGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['minImportance'] == null) {
            throw new runtime.RequiredError(
                'minImportance',
                'Required parameter "minImportance" was null or undefined when calling getEntriesByImportanceApiV1KnowledgeEntriesImportanceMinImportanceGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/entries/importance/{min_importance}`;
        urlPath = urlPath.replace(`{${"min_importance"}}`, encodeURIComponent(String(requestParameters['minImportance'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить записи по важности
     * Get Entries By Importance
     */
    async getEntriesByImportanceApiV1KnowledgeEntriesImportanceMinImportanceGet(requestParameters: GetEntriesByImportanceApiV1KnowledgeEntriesImportanceMinImportanceGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getEntriesByImportanceApiV1KnowledgeEntriesImportanceMinImportanceGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить записи по типу
     * Get Entries By Type
     */
    async getEntriesByTypeApiV1KnowledgeEntriesTypeEntryTypeGetRaw(requestParameters: GetEntriesByTypeApiV1KnowledgeEntriesTypeEntryTypeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['entryType'] == null) {
            throw new runtime.RequiredError(
                'entryType',
                'Required parameter "entryType" was null or undefined when calling getEntriesByTypeApiV1KnowledgeEntriesTypeEntryTypeGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/entries/type/{entry_type}`;
        urlPath = urlPath.replace(`{${"entry_type"}}`, encodeURIComponent(String(requestParameters['entryType'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить записи по типу
     * Get Entries By Type
     */
    async getEntriesByTypeApiV1KnowledgeEntriesTypeEntryTypeGet(requestParameters: GetEntriesByTypeApiV1KnowledgeEntriesTypeEntryTypeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getEntriesByTypeApiV1KnowledgeEntriesTypeEntryTypeGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить запись по ID
     * Get Entry
     */
    async getEntryApiV1KnowledgeEntriesEntryIdGetRaw(requestParameters: GetEntryApiV1KnowledgeEntriesEntryIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['entryId'] == null) {
            throw new runtime.RequiredError(
                'entryId',
                'Required parameter "entryId" was null or undefined when calling getEntryApiV1KnowledgeEntriesEntryIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/entries/{entry_id}`;
        urlPath = urlPath.replace(`{${"entry_id"}}`, encodeURIComponent(String(requestParameters['entryId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить запись по ID
     * Get Entry
     */
    async getEntryApiV1KnowledgeEntriesEntryIdGet(requestParameters: GetEntryApiV1KnowledgeEntriesEntryIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getEntryApiV1KnowledgeEntriesEntryIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить запись по арабскому термину
     * Get Entry By Arabic Term
     */
    async getEntryByArabicTermApiV1KnowledgeEntriesByTermTermArabicGetRaw(requestParameters: GetEntryByArabicTermApiV1KnowledgeEntriesByTermTermArabicGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['termArabic'] == null) {
            throw new runtime.RequiredError(
                'termArabic',
                'Required parameter "termArabic" was null or undefined when calling getEntryByArabicTermApiV1KnowledgeEntriesByTermTermArabicGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/entries/by-term/{term_arabic}`;
        urlPath = urlPath.replace(`{${"term_arabic"}}`, encodeURIComponent(String(requestParameters['termArabic'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить запись по арабскому термину
     * Get Entry By Arabic Term
     */
    async getEntryByArabicTermApiV1KnowledgeEntriesByTermTermArabicGet(requestParameters: GetEntryByArabicTermApiV1KnowledgeEntriesByTermTermArabicGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getEntryByArabicTermApiV1KnowledgeEntriesByTermTermArabicGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить запись по транслитерации
     * Get Entry By Transliteration
     */
    async getEntryByTransliterationApiV1KnowledgeEntriesByTransliterationTransliterationGetRaw(requestParameters: GetEntryByTransliterationApiV1KnowledgeEntriesByTransliterationTransliterationGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['transliteration'] == null) {
            throw new runtime.RequiredError(
                'transliteration',
                'Required parameter "transliteration" was null or undefined when calling getEntryByTransliterationApiV1KnowledgeEntriesByTransliterationTransliterationGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/entries/by-transliteration/{transliteration}`;
        urlPath = urlPath.replace(`{${"transliteration"}}`, encodeURIComponent(String(requestParameters['transliteration'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить запись по транслитерации
     * Get Entry By Transliteration
     */
    async getEntryByTransliterationApiV1KnowledgeEntriesByTransliterationTransliterationGet(requestParameters: GetEntryByTransliterationApiV1KnowledgeEntriesByTransliterationTransliterationGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getEntryByTransliterationApiV1KnowledgeEntriesByTransliterationTransliterationGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить полную информацию о записи со всеми связанными данными
     * Get Entry Full Info
     */
    async getEntryFullInfoApiV1KnowledgeEntriesEntryIdFullGetRaw(requestParameters: GetEntryFullInfoApiV1KnowledgeEntriesEntryIdFullGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['entryId'] == null) {
            throw new runtime.RequiredError(
                'entryId',
                'Required parameter "entryId" was null or undefined when calling getEntryFullInfoApiV1KnowledgeEntriesEntryIdFullGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/entries/{entry_id}/full`;
        urlPath = urlPath.replace(`{${"entry_id"}}`, encodeURIComponent(String(requestParameters['entryId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить полную информацию о записи со всеми связанными данными
     * Get Entry Full Info
     */
    async getEntryFullInfoApiV1KnowledgeEntriesEntryIdFullGet(requestParameters: GetEntryFullInfoApiV1KnowledgeEntriesEntryIdFullGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getEntryFullInfoApiV1KnowledgeEntriesEntryIdFullGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить примеры для записи
     * Get Examples By Entry
     */
    async getExamplesByEntryApiV1KnowledgeEntriesEntryIdExamplesGetRaw(requestParameters: GetExamplesByEntryApiV1KnowledgeEntriesEntryIdExamplesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['entryId'] == null) {
            throw new runtime.RequiredError(
                'entryId',
                'Required parameter "entryId" was null or undefined when calling getExamplesByEntryApiV1KnowledgeEntriesEntryIdExamplesGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/entries/{entry_id}/examples`;
        urlPath = urlPath.replace(`{${"entry_id"}}`, encodeURIComponent(String(requestParameters['entryId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить примеры для записи
     * Get Examples By Entry
     */
    async getExamplesByEntryApiV1KnowledgeEntriesEntryIdExamplesGet(requestParameters: GetExamplesByEntryApiV1KnowledgeEntriesEntryIdExamplesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getExamplesByEntryApiV1KnowledgeEntriesEntryIdExamplesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить медиа файлы для записи
     * Get Media By Entry
     */
    async getMediaByEntryApiV1KnowledgeEntriesEntryIdMediaGetRaw(requestParameters: GetMediaByEntryApiV1KnowledgeEntriesEntryIdMediaGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['entryId'] == null) {
            throw new runtime.RequiredError(
                'entryId',
                'Required parameter "entryId" was null or undefined when calling getMediaByEntryApiV1KnowledgeEntriesEntryIdMediaGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/entries/{entry_id}/media`;
        urlPath = urlPath.replace(`{${"entry_id"}}`, encodeURIComponent(String(requestParameters['entryId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить медиа файлы для записи
     * Get Media By Entry
     */
    async getMediaByEntryApiV1KnowledgeEntriesEntryIdMediaGet(requestParameters: GetMediaByEntryApiV1KnowledgeEntriesEntryIdMediaGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getMediaByEntryApiV1KnowledgeEntriesEntryIdMediaGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить медиа файлы определенного типа
     * Get Media By Type
     */
    async getMediaByTypeApiV1KnowledgeEntriesEntryIdMediaMediaTypeGetRaw(requestParameters: GetMediaByTypeApiV1KnowledgeEntriesEntryIdMediaMediaTypeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['entryId'] == null) {
            throw new runtime.RequiredError(
                'entryId',
                'Required parameter "entryId" was null or undefined when calling getMediaByTypeApiV1KnowledgeEntriesEntryIdMediaMediaTypeGet().'
            );
        }

        if (requestParameters['mediaType'] == null) {
            throw new runtime.RequiredError(
                'mediaType',
                'Required parameter "mediaType" was null or undefined when calling getMediaByTypeApiV1KnowledgeEntriesEntryIdMediaMediaTypeGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/entries/{entry_id}/media/{media_type}`;
        urlPath = urlPath.replace(`{${"entry_id"}}`, encodeURIComponent(String(requestParameters['entryId'])));
        urlPath = urlPath.replace(`{${"media_type"}}`, encodeURIComponent(String(requestParameters['mediaType'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить медиа файлы определенного типа
     * Get Media By Type
     */
    async getMediaByTypeApiV1KnowledgeEntriesEntryIdMediaMediaTypeGet(requestParameters: GetMediaByTypeApiV1KnowledgeEntriesEntryIdMediaMediaTypeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getMediaByTypeApiV1KnowledgeEntriesEntryIdMediaMediaTypeGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить случайную запись
     * Get Random Entry
     */
    async getRandomEntryApiV1KnowledgeEntriesRandomGetRaw(requestParameters: GetRandomEntryApiV1KnowledgeEntriesRandomGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        if (requestParameters['category'] != null) {
            queryParameters['category'] = requestParameters['category'];
        }

        if (requestParameters['entryType'] != null) {
            queryParameters['entry_type'] = requestParameters['entryType'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/entries/random`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить случайную запись
     * Get Random Entry
     */
    async getRandomEntryApiV1KnowledgeEntriesRandomGet(requestParameters: GetRandomEntryApiV1KnowledgeEntriesRandomGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getRandomEntryApiV1KnowledgeEntriesRandomGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить источники для записи
     * Get Sources By Entry
     */
    async getSourcesByEntryApiV1KnowledgeEntriesEntryIdSourcesGetRaw(requestParameters: GetSourcesByEntryApiV1KnowledgeEntriesEntryIdSourcesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['entryId'] == null) {
            throw new runtime.RequiredError(
                'entryId',
                'Required parameter "entryId" was null or undefined when calling getSourcesByEntryApiV1KnowledgeEntriesEntryIdSourcesGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/entries/{entry_id}/sources`;
        urlPath = urlPath.replace(`{${"entry_id"}}`, encodeURIComponent(String(requestParameters['entryId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить источники для записи
     * Get Sources By Entry
     */
    async getSourcesByEntryApiV1KnowledgeEntriesEntryIdSourcesGet(requestParameters: GetSourcesByEntryApiV1KnowledgeEntriesEntryIdSourcesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getSourcesByEntryApiV1KnowledgeEntriesEntryIdSourcesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить источники определенного типа
     * Get Sources By Type
     */
    async getSourcesByTypeApiV1KnowledgeEntriesEntryIdSourcesSourceTypeGetRaw(requestParameters: GetSourcesByTypeApiV1KnowledgeEntriesEntryIdSourcesSourceTypeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['entryId'] == null) {
            throw new runtime.RequiredError(
                'entryId',
                'Required parameter "entryId" was null or undefined when calling getSourcesByTypeApiV1KnowledgeEntriesEntryIdSourcesSourceTypeGet().'
            );
        }

        if (requestParameters['sourceType'] == null) {
            throw new runtime.RequiredError(
                'sourceType',
                'Required parameter "sourceType" was null or undefined when calling getSourcesByTypeApiV1KnowledgeEntriesEntryIdSourcesSourceTypeGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/entries/{entry_id}/sources/{source_type}`;
        urlPath = urlPath.replace(`{${"entry_id"}}`, encodeURIComponent(String(requestParameters['entryId'])));
        urlPath = urlPath.replace(`{${"source_type"}}`, encodeURIComponent(String(requestParameters['sourceType'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить источники определенного типа
     * Get Sources By Type
     */
    async getSourcesByTypeApiV1KnowledgeEntriesEntryIdSourcesSourceTypeGet(requestParameters: GetSourcesByTypeApiV1KnowledgeEntriesEntryIdSourcesSourceTypeGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getSourcesByTypeApiV1KnowledgeEntriesEntryIdSourcesSourceTypeGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить общее количество активных записей
     * Get Total Count
     */
    async getTotalCountApiV1KnowledgeStatsTotalGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/stats/total`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить общее количество активных записей
     * Get Total Count
     */
    async getTotalCountApiV1KnowledgeStatsTotalGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getTotalCountApiV1KnowledgeStatsTotalGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Получить перевод на конкретном языке
     * Get Translation By Language
     */
    async getTranslationByLanguageApiV1KnowledgeEntriesEntryIdTranslationsLanguageGetRaw(requestParameters: GetTranslationByLanguageApiV1KnowledgeEntriesEntryIdTranslationsLanguageGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['entryId'] == null) {
            throw new runtime.RequiredError(
                'entryId',
                'Required parameter "entryId" was null or undefined when calling getTranslationByLanguageApiV1KnowledgeEntriesEntryIdTranslationsLanguageGet().'
            );
        }

        if (requestParameters['language'] == null) {
            throw new runtime.RequiredError(
                'language',
                'Required parameter "language" was null or undefined when calling getTranslationByLanguageApiV1KnowledgeEntriesEntryIdTranslationsLanguageGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/entries/{entry_id}/translations/{language}`;
        urlPath = urlPath.replace(`{${"entry_id"}}`, encodeURIComponent(String(requestParameters['entryId'])));
        urlPath = urlPath.replace(`{${"language"}}`, encodeURIComponent(String(requestParameters['language'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить перевод на конкретном языке
     * Get Translation By Language
     */
    async getTranslationByLanguageApiV1KnowledgeEntriesEntryIdTranslationsLanguageGet(requestParameters: GetTranslationByLanguageApiV1KnowledgeEntriesEntryIdTranslationsLanguageGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getTranslationByLanguageApiV1KnowledgeEntriesEntryIdTranslationsLanguageGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить переводы для записи
     * Get Translations By Entry
     */
    async getTranslationsByEntryApiV1KnowledgeEntriesEntryIdTranslationsGetRaw(requestParameters: GetTranslationsByEntryApiV1KnowledgeEntriesEntryIdTranslationsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['entryId'] == null) {
            throw new runtime.RequiredError(
                'entryId',
                'Required parameter "entryId" was null or undefined when calling getTranslationsByEntryApiV1KnowledgeEntriesEntryIdTranslationsGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/entries/{entry_id}/translations`;
        urlPath = urlPath.replace(`{${"entry_id"}}`, encodeURIComponent(String(requestParameters['entryId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить переводы для записи
     * Get Translations By Entry
     */
    async getTranslationsByEntryApiV1KnowledgeEntriesEntryIdTranslationsGet(requestParameters: GetTranslationsByEntryApiV1KnowledgeEntriesEntryIdTranslationsGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getTranslationsByEntryApiV1KnowledgeEntriesEntryIdTranslationsGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Получить статистику по типам
     * Get Type Stats
     */
    async getTypeStatsApiV1KnowledgeStatsTypesGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/stats/types`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Получить статистику по типам
     * Get Type Stats
     */
    async getTypeStatsApiV1KnowledgeStatsTypesGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getTypeStatsApiV1KnowledgeStatsTypesGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Проверка здоровья API
     * Health Check
     */
    async healthCheckApiV1KnowledgeHealthGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/health`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Проверка здоровья API
     * Health Check
     */
    async healthCheckApiV1KnowledgeHealthGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.healthCheckApiV1KnowledgeHealthGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Поиск записей по тексту
     * Search Entries
     */
    async searchEntriesApiV1KnowledgeSearchGetRaw(requestParameters: SearchEntriesApiV1KnowledgeSearchGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['q'] == null) {
            throw new runtime.RequiredError(
                'q',
                'Required parameter "q" was null or undefined when calling searchEntriesApiV1KnowledgeSearchGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        if (requestParameters['category'] != null) {
            queryParameters['category'] = requestParameters['category'];
        }

        if (requestParameters['entryType'] != null) {
            queryParameters['entry_type'] = requestParameters['entryType'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/search`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Поиск записей по тексту
     * Search Entries
     */
    async searchEntriesApiV1KnowledgeSearchGet(requestParameters: SearchEntriesApiV1KnowledgeSearchGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.searchEntriesApiV1KnowledgeSearchGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Поиск записей по тексту (POST для поддержки кириллицы)
     * Search Entries Post
     */
    async searchEntriesPostApiV1KnowledgeSearchPostRaw(requestParameters: SearchEntriesPostApiV1KnowledgeSearchPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling searchEntriesPostApiV1KnowledgeSearchPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/search`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Поиск записей по тексту (POST для поддержки кириллицы)
     * Search Entries Post
     */
    async searchEntriesPostApiV1KnowledgeSearchPost(requestParameters: SearchEntriesPostApiV1KnowledgeSearchPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.searchEntriesPostApiV1KnowledgeSearchPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Семантический поиск (заглушка для будущей реализации)
     * Semantic Search
     */
    async semanticSearchApiV1KnowledgeSearchSemanticPostRaw(requestParameters: SemanticSearchApiV1KnowledgeSearchSemanticPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['query'] == null) {
            throw new runtime.RequiredError(
                'query',
                'Required parameter "query" was null or undefined when calling semanticSearchApiV1KnowledgeSearchSemanticPost().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['query'] != null) {
            queryParameters['query'] = requestParameters['query'];
        }

        if (requestParameters['category'] != null) {
            queryParameters['category'] = requestParameters['category'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/search/semantic`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Семантический поиск (заглушка для будущей реализации)
     * Semantic Search
     */
    async semanticSearchApiV1KnowledgeSearchSemanticPost(requestParameters: SemanticSearchApiV1KnowledgeSearchSemanticPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.semanticSearchApiV1KnowledgeSearchSemanticPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Автоподсказки для текста на основе поиска терминов
     * Suggest Terms
     */
    async suggestTermsApiV1KnowledgeSuggestGetRaw(requestParameters: SuggestTermsApiV1KnowledgeSuggestGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['q'] == null) {
            throw new runtime.RequiredError(
                'q',
                'Required parameter "q" was null or undefined when calling suggestTermsApiV1KnowledgeSuggestGet().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/suggest`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Автоподсказки для текста на основе поиска терминов
     * Suggest Terms
     */
    async suggestTermsApiV1KnowledgeSuggestGet(requestParameters: SuggestTermsApiV1KnowledgeSuggestGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.suggestTermsApiV1KnowledgeSuggestGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Обновить запись (только для админов)
     * Update Entry
     */
    async updateEntryApiV1KnowledgeEntriesEntryIdPutRaw(requestParameters: UpdateEntryApiV1KnowledgeEntriesEntryIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['entryId'] == null) {
            throw new runtime.RequiredError(
                'entryId',
                'Required parameter "entryId" was null or undefined when calling updateEntryApiV1KnowledgeEntriesEntryIdPut().'
            );
        }

        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling updateEntryApiV1KnowledgeEntriesEntryIdPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/entries/{entry_id}`;
        urlPath = urlPath.replace(`{${"entry_id"}}`, encodeURIComponent(String(requestParameters['entryId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Обновить запись (только для админов)
     * Update Entry
     */
    async updateEntryApiV1KnowledgeEntriesEntryIdPut(requestParameters: UpdateEntryApiV1KnowledgeEntriesEntryIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.updateEntryApiV1KnowledgeEntriesEntryIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Обновить пример (только для админов)
     * Update Example
     */
    async updateExampleApiV1KnowledgeExamplesExampleIdPutRaw(requestParameters: UpdateExampleApiV1KnowledgeExamplesExampleIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['exampleId'] == null) {
            throw new runtime.RequiredError(
                'exampleId',
                'Required parameter "exampleId" was null or undefined when calling updateExampleApiV1KnowledgeExamplesExampleIdPut().'
            );
        }

        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling updateExampleApiV1KnowledgeExamplesExampleIdPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/examples/{example_id}`;
        urlPath = urlPath.replace(`{${"example_id"}}`, encodeURIComponent(String(requestParameters['exampleId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Обновить пример (только для админов)
     * Update Example
     */
    async updateExampleApiV1KnowledgeExamplesExampleIdPut(requestParameters: UpdateExampleApiV1KnowledgeExamplesExampleIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.updateExampleApiV1KnowledgeExamplesExampleIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Обновить медиа запись (только для админов)
     * Update Media
     */
    async updateMediaApiV1KnowledgeMediaMediaIdPutRaw(requestParameters: UpdateMediaApiV1KnowledgeMediaMediaIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['mediaId'] == null) {
            throw new runtime.RequiredError(
                'mediaId',
                'Required parameter "mediaId" was null or undefined when calling updateMediaApiV1KnowledgeMediaMediaIdPut().'
            );
        }

        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling updateMediaApiV1KnowledgeMediaMediaIdPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/media/{media_id}`;
        urlPath = urlPath.replace(`{${"media_id"}}`, encodeURIComponent(String(requestParameters['mediaId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Обновить медиа запись (только для админов)
     * Update Media
     */
    async updateMediaApiV1KnowledgeMediaMediaIdPut(requestParameters: UpdateMediaApiV1KnowledgeMediaMediaIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.updateMediaApiV1KnowledgeMediaMediaIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Обновить источник (только для админов)
     * Update Source
     */
    async updateSourceApiV1KnowledgeSourcesSourceIdPutRaw(requestParameters: UpdateSourceApiV1KnowledgeSourcesSourceIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['sourceId'] == null) {
            throw new runtime.RequiredError(
                'sourceId',
                'Required parameter "sourceId" was null or undefined when calling updateSourceApiV1KnowledgeSourcesSourceIdPut().'
            );
        }

        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling updateSourceApiV1KnowledgeSourcesSourceIdPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/sources/{source_id}`;
        urlPath = urlPath.replace(`{${"source_id"}}`, encodeURIComponent(String(requestParameters['sourceId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Обновить источник (только для админов)
     * Update Source
     */
    async updateSourceApiV1KnowledgeSourcesSourceIdPut(requestParameters: UpdateSourceApiV1KnowledgeSourcesSourceIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.updateSourceApiV1KnowledgeSourcesSourceIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Обновить перевод (только для админов)
     * Update Translation
     */
    async updateTranslationApiV1KnowledgeTranslationsTranslationIdPutRaw(requestParameters: UpdateTranslationApiV1KnowledgeTranslationsTranslationIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['translationId'] == null) {
            throw new runtime.RequiredError(
                'translationId',
                'Required parameter "translationId" was null or undefined when calling updateTranslationApiV1KnowledgeTranslationsTranslationIdPut().'
            );
        }

        if (requestParameters['requestBody'] == null) {
            throw new runtime.RequiredError(
                'requestBody',
                'Required parameter "requestBody" was null or undefined when calling updateTranslationApiV1KnowledgeTranslationsTranslationIdPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/knowledge/translations/{translation_id}`;
        urlPath = urlPath.replace(`{${"translation_id"}}`, encodeURIComponent(String(requestParameters['translationId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: requestParameters['requestBody'],
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Обновить перевод (только для админов)
     * Update Translation
     */
    async updateTranslationApiV1KnowledgeTranslationsTranslationIdPut(requestParameters: UpdateTranslationApiV1KnowledgeTranslationsTranslationIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.updateTranslationApiV1KnowledgeTranslationsTranslationIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
