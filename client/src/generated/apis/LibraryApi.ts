/* tslint:disable */
/* eslint-disable */
/**
 * Платформа Духовных Практик Gateway API
 *          ## Публичный REST API шлюз для платформы духовных практик                  ### Аутентификация         Все эндпоинты (кроме `/api/v1/auth/_*`) требуют JWT Bearer токен в заголовке Authorization.                  ### Основные возможности:         - **Цели (Goals)**: Управление духовными целями пользователей         - **Тасбих (Tasbih)**: Счетчик для духовных практик         - **Азкары (Azkar)**: Ежедневные поминания         - **Quran API**: Работа с Кораном, переводами и аудио         - **Библиотека**: Управление пользовательским контентом         - **Отчеты**: Генерация отчетов о духовной активности                  ### Статус коды:         - `200` - Успешный запрос         - `201` - Ресурс создан         - `400` - Неверный формат запроса         - `401` - Требуется авторизация         - `403` - Доступ запрещен         - `404` - Ресурс не найден         - `422` - Ошибка валидации данных         - `500` - Внутренняя ошибка сервера         - `503` - Сервис недоступен                  ### Health Checks:         - `GET /health` - Базовый health check         - `GET /health/ready` - Readiness probe (Kubernetes)         - `GET /health/live` - Liveness probe (Kubernetes)         - `GET /metrics` - Prometheus метрики         
 *
 * The version of the OpenAPI document: 1.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  Book,
  HTTPValidationError,
  LibrarySection,
  ReadingProgress,
  ReadingProgressUpdate,
} from '../models/index';
import {
    BookFromJSON,
    BookToJSON,
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    LibrarySectionFromJSON,
    LibrarySectionToJSON,
    ReadingProgressFromJSON,
    ReadingProgressToJSON,
    ReadingProgressUpdateFromJSON,
    ReadingProgressUpdateToJSON,
} from '../models/index';

export interface CreateBookApiV1LibraryBooksPostRequest {
    book: Book;
}

export interface DeleteBookApiV1LibraryBooksBookIdDeleteRequest {
    bookId: string;
}

export interface DeleteReadingProgressApiV1LibraryProgressBookIdDeleteRequest {
    bookId: string;
}

export interface GetLibraryBookApiV1LibraryBooksBookIdGetRequest {
    bookId: string;
}

export interface GetLibraryBooksApiV1LibraryBooksGetRequest {
    tier?: string | null;
    q?: string | null;
    tags?: string | null;
}

export interface UpdateBookApiV1LibraryBooksBookIdPutRequest {
    bookId: string;
    book: Book;
}

export interface UpdateReadingProgressApiV1LibraryBooksBookIdProgressPostRequest {
    bookId: string;
    readingProgressUpdate: ReadingProgressUpdate;
}

export interface UpdateReadingProgressApiV1LibraryProgressBookIdPutRequest {
    bookId: string;
    readingProgress: ReadingProgress;
}

/**
 * LibraryApi - interface
 * 
 * @export
 * @interface LibraryApiInterface
 */
export interface LibraryApiInterface {
    /**
     * Создать новую книгу (только для админов)
     * @summary Create Book
     * @param {Book} book 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApiInterface
     */
    createBookApiV1LibraryBooksPostRaw(requestParameters: CreateBookApiV1LibraryBooksPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Book>>;

    /**
     * Создать новую книгу (только для админов)
     * Create Book
     */
    createBookApiV1LibraryBooksPost(requestParameters: CreateBookApiV1LibraryBooksPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Book>;

    /**
     * Удалить книгу (только для админов)
     * @summary Delete Book
     * @param {string} bookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApiInterface
     */
    deleteBookApiV1LibraryBooksBookIdDeleteRaw(requestParameters: DeleteBookApiV1LibraryBooksBookIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Удалить книгу (только для админов)
     * Delete Book
     */
    deleteBookApiV1LibraryBooksBookIdDelete(requestParameters: DeleteBookApiV1LibraryBooksBookIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Удалить прогресс чтения
     * @summary Delete Reading Progress
     * @param {string} bookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApiInterface
     */
    deleteReadingProgressApiV1LibraryProgressBookIdDeleteRaw(requestParameters: DeleteReadingProgressApiV1LibraryProgressBookIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Удалить прогресс чтения
     * Delete Reading Progress
     */
    deleteReadingProgressApiV1LibraryProgressBookIdDelete(requestParameters: DeleteReadingProgressApiV1LibraryProgressBookIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Get book details
     * @summary Get Library Book
     * @param {string} bookId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApiInterface
     */
    getLibraryBookApiV1LibraryBooksBookIdGetRaw(requestParameters: GetLibraryBookApiV1LibraryBooksBookIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Book>>;

    /**
     * Get book details
     * Get Library Book
     */
    getLibraryBookApiV1LibraryBooksBookIdGet(requestParameters: GetLibraryBookApiV1LibraryBooksBookIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Book>;

    /**
     * Get library books
     * @summary Get Library Books
     * @param {string} [tier] Filter by subscription tier
     * @param {string} [q] Search query
     * @param {string} [tags] Filter by tags (comma-separated)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApiInterface
     */
    getLibraryBooksApiV1LibraryBooksGetRaw(requestParameters: GetLibraryBooksApiV1LibraryBooksGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>>;

    /**
     * Get library books
     * Get Library Books
     */
    getLibraryBooksApiV1LibraryBooksGet(requestParameters: GetLibraryBooksApiV1LibraryBooksGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any>;

    /**
     * Get library sections
     * @summary Get Library Sections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApiInterface
     */
    getLibrarySectionsApiV1LibrarySectionsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<LibrarySection>>>;

    /**
     * Get library sections
     * Get Library Sections
     */
    getLibrarySectionsApiV1LibrarySectionsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<LibrarySection>>;

    /**
     * Get reading progress
     * @summary Get Reading Progress
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApiInterface
     */
    getReadingProgressApiV1LibraryProgressGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ReadingProgress>>>;

    /**
     * Get reading progress
     * Get Reading Progress
     */
    getReadingProgressApiV1LibraryProgressGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ReadingProgress>>;

    /**
     * Обновить книгу (только для админов)
     * @summary Update Book
     * @param {string} bookId 
     * @param {Book} book 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApiInterface
     */
    updateBookApiV1LibraryBooksBookIdPutRaw(requestParameters: UpdateBookApiV1LibraryBooksBookIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Book>>;

    /**
     * Обновить книгу (только для админов)
     * Update Book
     */
    updateBookApiV1LibraryBooksBookIdPut(requestParameters: UpdateBookApiV1LibraryBooksBookIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Book>;

    /**
     * Update reading progress
     * @summary Update Reading Progress
     * @param {string} bookId 
     * @param {ReadingProgressUpdate} readingProgressUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApiInterface
     */
    updateReadingProgressApiV1LibraryBooksBookIdProgressPostRaw(requestParameters: UpdateReadingProgressApiV1LibraryBooksBookIdProgressPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReadingProgress>>;

    /**
     * Update reading progress
     * Update Reading Progress
     */
    updateReadingProgressApiV1LibraryBooksBookIdProgressPost(requestParameters: UpdateReadingProgressApiV1LibraryBooksBookIdProgressPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReadingProgress>;

    /**
     * Обновить прогресс чтения
     * @summary Update Reading Progress
     * @param {string} bookId 
     * @param {ReadingProgress} readingProgress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LibraryApiInterface
     */
    updateReadingProgressApiV1LibraryProgressBookIdPutRaw(requestParameters: UpdateReadingProgressApiV1LibraryProgressBookIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReadingProgress>>;

    /**
     * Обновить прогресс чтения
     * Update Reading Progress
     */
    updateReadingProgressApiV1LibraryProgressBookIdPut(requestParameters: UpdateReadingProgressApiV1LibraryProgressBookIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReadingProgress>;

}

/**
 * 
 */
export class LibraryApi extends runtime.BaseAPI implements LibraryApiInterface {

    /**
     * Создать новую книгу (только для админов)
     * Create Book
     */
    async createBookApiV1LibraryBooksPostRaw(requestParameters: CreateBookApiV1LibraryBooksPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Book>> {
        if (requestParameters['book'] == null) {
            throw new runtime.RequiredError(
                'book',
                'Required parameter "book" was null or undefined when calling createBookApiV1LibraryBooksPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/library/books`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BookToJSON(requestParameters['book']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BookFromJSON(jsonValue));
    }

    /**
     * Создать новую книгу (только для админов)
     * Create Book
     */
    async createBookApiV1LibraryBooksPost(requestParameters: CreateBookApiV1LibraryBooksPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Book> {
        const response = await this.createBookApiV1LibraryBooksPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Удалить книгу (только для админов)
     * Delete Book
     */
    async deleteBookApiV1LibraryBooksBookIdDeleteRaw(requestParameters: DeleteBookApiV1LibraryBooksBookIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['bookId'] == null) {
            throw new runtime.RequiredError(
                'bookId',
                'Required parameter "bookId" was null or undefined when calling deleteBookApiV1LibraryBooksBookIdDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/library/books/{book_id}`;
        urlPath = urlPath.replace(`{${"book_id"}}`, encodeURIComponent(String(requestParameters['bookId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Удалить книгу (только для админов)
     * Delete Book
     */
    async deleteBookApiV1LibraryBooksBookIdDelete(requestParameters: DeleteBookApiV1LibraryBooksBookIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deleteBookApiV1LibraryBooksBookIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Удалить прогресс чтения
     * Delete Reading Progress
     */
    async deleteReadingProgressApiV1LibraryProgressBookIdDeleteRaw(requestParameters: DeleteReadingProgressApiV1LibraryProgressBookIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['bookId'] == null) {
            throw new runtime.RequiredError(
                'bookId',
                'Required parameter "bookId" was null or undefined when calling deleteReadingProgressApiV1LibraryProgressBookIdDelete().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/library/progress/{book_id}`;
        urlPath = urlPath.replace(`{${"book_id"}}`, encodeURIComponent(String(requestParameters['bookId'])));

        const response = await this.request({
            path: urlPath,
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Удалить прогресс чтения
     * Delete Reading Progress
     */
    async deleteReadingProgressApiV1LibraryProgressBookIdDelete(requestParameters: DeleteReadingProgressApiV1LibraryProgressBookIdDeleteRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.deleteReadingProgressApiV1LibraryProgressBookIdDeleteRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get book details
     * Get Library Book
     */
    async getLibraryBookApiV1LibraryBooksBookIdGetRaw(requestParameters: GetLibraryBookApiV1LibraryBooksBookIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Book>> {
        if (requestParameters['bookId'] == null) {
            throw new runtime.RequiredError(
                'bookId',
                'Required parameter "bookId" was null or undefined when calling getLibraryBookApiV1LibraryBooksBookIdGet().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/library/books/{book_id}`;
        urlPath = urlPath.replace(`{${"book_id"}}`, encodeURIComponent(String(requestParameters['bookId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BookFromJSON(jsonValue));
    }

    /**
     * Get book details
     * Get Library Book
     */
    async getLibraryBookApiV1LibraryBooksBookIdGet(requestParameters: GetLibraryBookApiV1LibraryBooksBookIdGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Book> {
        const response = await this.getLibraryBookApiV1LibraryBooksBookIdGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get library books
     * Get Library Books
     */
    async getLibraryBooksApiV1LibraryBooksGetRaw(requestParameters: GetLibraryBooksApiV1LibraryBooksGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        const queryParameters: any = {};

        if (requestParameters['tier'] != null) {
            queryParameters['tier'] = requestParameters['tier'];
        }

        if (requestParameters['q'] != null) {
            queryParameters['q'] = requestParameters['q'];
        }

        if (requestParameters['tags'] != null) {
            queryParameters['tags'] = requestParameters['tags'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/library/books`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Get library books
     * Get Library Books
     */
    async getLibraryBooksApiV1LibraryBooksGet(requestParameters: GetLibraryBooksApiV1LibraryBooksGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.getLibraryBooksApiV1LibraryBooksGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get library sections
     * Get Library Sections
     */
    async getLibrarySectionsApiV1LibrarySectionsGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<LibrarySection>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/library/sections`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(LibrarySectionFromJSON));
    }

    /**
     * Get library sections
     * Get Library Sections
     */
    async getLibrarySectionsApiV1LibrarySectionsGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<LibrarySection>> {
        const response = await this.getLibrarySectionsApiV1LibrarySectionsGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get reading progress
     * Get Reading Progress
     */
    async getReadingProgressApiV1LibraryProgressGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<ReadingProgress>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/library/progress`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(ReadingProgressFromJSON));
    }

    /**
     * Get reading progress
     * Get Reading Progress
     */
    async getReadingProgressApiV1LibraryProgressGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<ReadingProgress>> {
        const response = await this.getReadingProgressApiV1LibraryProgressGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Обновить книгу (только для админов)
     * Update Book
     */
    async updateBookApiV1LibraryBooksBookIdPutRaw(requestParameters: UpdateBookApiV1LibraryBooksBookIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Book>> {
        if (requestParameters['bookId'] == null) {
            throw new runtime.RequiredError(
                'bookId',
                'Required parameter "bookId" was null or undefined when calling updateBookApiV1LibraryBooksBookIdPut().'
            );
        }

        if (requestParameters['book'] == null) {
            throw new runtime.RequiredError(
                'book',
                'Required parameter "book" was null or undefined when calling updateBookApiV1LibraryBooksBookIdPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/library/books/{book_id}`;
        urlPath = urlPath.replace(`{${"book_id"}}`, encodeURIComponent(String(requestParameters['bookId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: BookToJSON(requestParameters['book']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BookFromJSON(jsonValue));
    }

    /**
     * Обновить книгу (только для админов)
     * Update Book
     */
    async updateBookApiV1LibraryBooksBookIdPut(requestParameters: UpdateBookApiV1LibraryBooksBookIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Book> {
        const response = await this.updateBookApiV1LibraryBooksBookIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update reading progress
     * Update Reading Progress
     */
    async updateReadingProgressApiV1LibraryBooksBookIdProgressPostRaw(requestParameters: UpdateReadingProgressApiV1LibraryBooksBookIdProgressPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReadingProgress>> {
        if (requestParameters['bookId'] == null) {
            throw new runtime.RequiredError(
                'bookId',
                'Required parameter "bookId" was null or undefined when calling updateReadingProgressApiV1LibraryBooksBookIdProgressPost().'
            );
        }

        if (requestParameters['readingProgressUpdate'] == null) {
            throw new runtime.RequiredError(
                'readingProgressUpdate',
                'Required parameter "readingProgressUpdate" was null or undefined when calling updateReadingProgressApiV1LibraryBooksBookIdProgressPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/library/books/{book_id}/progress`;
        urlPath = urlPath.replace(`{${"book_id"}}`, encodeURIComponent(String(requestParameters['bookId'])));

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ReadingProgressUpdateToJSON(requestParameters['readingProgressUpdate']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ReadingProgressFromJSON(jsonValue));
    }

    /**
     * Update reading progress
     * Update Reading Progress
     */
    async updateReadingProgressApiV1LibraryBooksBookIdProgressPost(requestParameters: UpdateReadingProgressApiV1LibraryBooksBookIdProgressPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReadingProgress> {
        const response = await this.updateReadingProgressApiV1LibraryBooksBookIdProgressPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Обновить прогресс чтения
     * Update Reading Progress
     */
    async updateReadingProgressApiV1LibraryProgressBookIdPutRaw(requestParameters: UpdateReadingProgressApiV1LibraryProgressBookIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ReadingProgress>> {
        if (requestParameters['bookId'] == null) {
            throw new runtime.RequiredError(
                'bookId',
                'Required parameter "bookId" was null or undefined when calling updateReadingProgressApiV1LibraryProgressBookIdPut().'
            );
        }

        if (requestParameters['readingProgress'] == null) {
            throw new runtime.RequiredError(
                'readingProgress',
                'Required parameter "readingProgress" was null or undefined when calling updateReadingProgressApiV1LibraryProgressBookIdPut().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("HTTPBearer", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/api/v1/library/progress/{book_id}`;
        urlPath = urlPath.replace(`{${"book_id"}}`, encodeURIComponent(String(requestParameters['bookId'])));

        const response = await this.request({
            path: urlPath,
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: ReadingProgressToJSON(requestParameters['readingProgress']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ReadingProgressFromJSON(jsonValue));
    }

    /**
     * Обновить прогресс чтения
     * Update Reading Progress
     */
    async updateReadingProgressApiV1LibraryProgressBookIdPut(requestParameters: UpdateReadingProgressApiV1LibraryProgressBookIdPutRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ReadingProgress> {
        const response = await this.updateReadingProgressApiV1LibraryProgressBookIdPutRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
